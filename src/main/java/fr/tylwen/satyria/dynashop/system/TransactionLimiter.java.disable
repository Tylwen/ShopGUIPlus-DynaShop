package fr.tylwen.satyria.dynashop.system;

import fr.tylwen.satyria.dynashop.DynaShopPlugin;
// import fr.tylwen.satyria.dynashop.system.TransactionLimiter.LimitPeriod;
// import fr.tylwen.satyria.dynashop.system.TransactionLimiter.TransactionLimit;
import fr.tylwen.satyria.dynashop.data.cache.LimitCacheEntry;
// import fr.tylwen.satyria.dynashop.system.TransactionLimiter.LimitPeriod;
// import fr.tylwen.satyria.dynashop.system.TransactionLimiter.TransactionLimit;

// import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
// import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAdjusters;
import java.util.ArrayList;
// import java.util.Calendar;
// import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
// import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;

public class TransactionLimiter {
    private final DynaShopPlugin plugin;
    private final ConcurrentLinkedQueue<TransactionRecord> flushQueue;
    private final Thread flushThread;
    
    private final Map<String, TransactionRecord> pendingTransactions = new ConcurrentHashMap<>();
    // private final Thread transactionFlushThread;
    private final AtomicBoolean running = new AtomicBoolean(true);
    
    // private final Map<String, TransactionLimit> limitCache = new ConcurrentHashMap<>();
    // private final long CACHE_DURATION = 60000; // 1 minute en millisecondes
    // private final Map<String, Long> limitCacheTimestamps = new ConcurrentHashMap<>();
    
    private final Map<String, Integer> transactionCounters = new ConcurrentHashMap<>();
    private long lastMetricsReset = System.currentTimeMillis();
    
    // public enum LimitPeriod {
    //     DAILY, WEEKLY, MONTHLY, YEARLY, FOREVER, NONE
    // }
    public enum LimitPeriod {
        DAILY(86400),    // 24 heures
        WEEKLY(604800),  // 7 jours
        MONTHLY(2592000),  // 30 jours
        YEARLY(31536000),  // 365 jours
        FOREVER(Integer.MAX_VALUE),
        NONE(0);
        
        private final int seconds;
        
        LimitPeriod(int seconds) {
            this.seconds = seconds;
        }
        
        public int getSeconds() {
            return seconds;
        }
        
        public static LimitPeriod fromString(String value) {
            try {
                return valueOf(value.toUpperCase());
            } catch (IllegalArgumentException e) {
                // Si c'est un nombre, considérer comme des secondes
                try {
                    int seconds = Integer.parseInt(value);
                    for (LimitPeriod period : values()) {
                        if (period.getSeconds() == seconds) {
                            return period;
                        }
                    }
                    return NONE; // Valeur personnalisée
                } catch (NumberFormatException ex) {
                    return NONE; // Valeur non reconnue
                }
            }
        }
    }
    
    public TransactionLimiter(DynaShopPlugin plugin) {
        this.plugin = plugin;
        this.flushQueue = new ConcurrentLinkedQueue<>();
        this.flushThread = new Thread(this::flushQueueWorker);
        this.flushThread.setName("DynaShop-LimitFlusher");
        this.flushThread.setDaemon(true);
        this.flushThread.start();
        // Ne pas initialiser la base de données en mode FLATFILE
        if (!plugin.getDataConfig().getDatabaseType().equals("flatfile")) {
            initDatabase();
        }
        // Appeler l'optimisation de la base de données au démarrage
        // plugin.getServer().getScheduler().runTaskAsynchronously(plugin, this::optimizeDatabase);
        
        // // Planifier une optimisation périodique (une fois par jour)
        // plugin.getServer().getScheduler().runTaskTimerAsynchronously(plugin, 
        //     // this::optimizeDatabase,
        //     this::cleanupExpiredTransactions,  // Au lieu de optimizeDatabase
        //     20L * 60L * 60L * 12L, // 12 heures après le démarrage
        //     20L * 60L * 60L * 24L  // Répéter toutes les 24 heures
        // );
        
        // // Thread de flush périodique
        // transactionFlushThread = Thread.ofVirtual()
        //     .name("DynaShop-TxFlusher")
        //     .start(() -> {
        //         while (running.get()) {
        //             try {
        //                 flushPendingTransactions();
        //                 Thread.sleep(1000); // flush toutes les secondes
        //             } catch (InterruptedException e) {
        //                 Thread.currentThread().interrupt();
        //                 break;
        //             }
        //         }
        //         flushPendingTransactions();
        //     });
    }

    /**
     * Méthode qui s'exécute dans un thread séparé pour traiter la file d'attente des transactions
     */
    private void flushQueueWorker() {
        while (running.get()) {
            try {
                // Traiter les transactions en attente
                TransactionRecord record = flushQueue.poll();
                if (record != null) {
                    // Éviter les exceptions dans le thread de flush qui pourraient arrêter le traitement
                    try {
                        // Utiliser ta logique existante pour insérer/mettre à jour dans la bonne table
                        // Utiliser le mode FLATFILE ou SQL selon la configuration
                        if (plugin.getDataConfig().getDatabaseType().equals("flatfile")) {
                            if (plugin.getFlatFileManager() != null) {
                                plugin.getFlatFileManager().getTransactionManager().addTransaction(record.playerUuid, record.shopId, record.itemId, record.isBuy, record.amount);
                            }
                        } else {
                            // Version SQL
                            recordTransactionToDatabase(record);
                        }
                        
                        // Incrémenter les compteurs pour les métriques
                        incrementCounter("processed_transactions");
                    } catch (Exception e) {
                        plugin.getLogger().severe("Erreur lors du traitement d'une transaction: " + e.getMessage());
                    }
                } else {
                    // Si la file est vide, attendre un peu avant de vérifier à nouveau
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                // Le thread a été interrompu, probablement lors de l'arrêt du plugin
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        // Vider la file d'attente avant de terminer
        TransactionRecord record;
        while ((record = flushQueue.poll()) != null) {
            try {
                if (plugin.getDataConfig().getDatabaseType().equals("flatfile")) {
                    if (plugin.getFlatFileManager() != null) {
                        plugin.getFlatFileManager().getTransactionManager()
                            .addTransaction(record.playerUuid, record.shopId, record.itemId, record.isBuy, record.amount);
                    }
                } else {
                    recordTransactionToDatabase(record);
                }
            } catch (Exception e) {
                plugin.getLogger().severe("Erreur lors du traitement final d'une transaction: " + e.getMessage());
            }
        }
    }

    /**
     * Méthode d'aide pour enregistrer une transaction dans la base de données
     */
    private void recordTransactionToDatabase(TransactionRecord record) {
        // Récupérer le joueur à partir de l'UUID si nécessaire
        Player player = plugin.getServer().getPlayer(record.playerUuid);
        if (player != null) {
            recordTransaction(player, record.shopId, record.itemId, record.isBuy, record.amount);
        } else {
            plugin.getLogger().warning("Le joueur avec UUID " + record.playerUuid + " n'est pas en ligne. Transaction non enregistrée.");
        }
    }

    // Pour sauvegarder les transactions en attente
    public void queueTransaction(Player player, String shopId, String itemId, boolean isBuy, int amount) {
        String key = player.getUniqueId() + ":" + shopId + ":" + itemId + ":" + (isBuy ? "BUY" : "SELL");
        pendingTransactions.merge(key, new TransactionRecord(player.getUniqueId(), shopId, itemId, isBuy, amount),
            (oldRec, newRec) -> new TransactionRecord(
                oldRec.playerUuid, oldRec.shopId, oldRec.itemId, oldRec.isBuy, oldRec.amount + newRec.amount
            )
        );
    }
    private void flushPendingTransactions() {
        if (pendingTransactions.isEmpty()) return;
        Map<String, TransactionRecord> toFlush = new HashMap<>(pendingTransactions);
        pendingTransactions.clear();

        for (TransactionRecord record : toFlush.values()) {
            // Utilise ta logique existante pour insérer/mise à jour dans la bonne table
            recordTransaction(
                // Tu dois pouvoir retrouver le Player à partir de l'UUID si besoin
                plugin.getServer().getPlayer(record.playerUuid),
                record.shopId, record.itemId, record.isBuy, record.amount
            );
        }
    }
    public void shutdown() {
        running.set(false);
        flushThread.interrupt();
        try {
            // Attendre la fin du thread avec un timeout raisonnable
            flushThread.join(5000);
        } catch (InterruptedException e) {
            plugin.getLogger().warning("Interrupted while waiting for database updater to finish");
            // Restaurer l'état d'interruption
            Thread.currentThread().interrupt();
        }
        
        // Si le thread ne s'est pas terminé proprement, forcer une dernière mise à jour
        if (flushThread.isAlive()) {
            plugin.getLogger().warning("Database updater thread did not terminate gracefully");
            flushPendingTransactions();
        }
    }

    public Map<String, Integer> getMetrics() {
        return new HashMap<>(transactionCounters);
    }

    public void incrementCounter(String metricName) {
        transactionCounters.merge(metricName, 1, Integer::sum);
    }
    
    private void initDatabase() {
        // Vérifier si nous sommes en mode flatfile - ne pas créer de tables SQL dans ce cas
        if (plugin.getDataConfig().getDatabaseType().equals("flatfile")) {
            plugin.getLogger().info("Mode FLATFILE détecté, les tables de transactions ne seront pas créées en SQL");
            return;
        }
        // String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        // String query = "CREATE TABLE IF NOT EXISTS " + tablePrefix + "_transaction_limits ("
        //         + "player_uuid VARCHAR(36) NOT NULL, "
        //         + "shop_id VARCHAR(100) NOT NULL, "
        //         + "item_id VARCHAR(100) NOT NULL, "
        //         + "transaction_type VARCHAR(10) NOT NULL, " // 'BUY' ou 'SELL'
        //         + "amount INT NOT NULL, "
        //         + "transaction_time TIMESTAMP NOT NULL, "
        //         + "PRIMARY KEY (player_uuid, shop_id, item_id, transaction_type, transaction_time)"
        //         + ")";
        
        // plugin.getDataManager().executeUpdate(query);

        // // Optionnel : ajouter un index pour améliorer les performances des requêtes
        
        // // Ajout d'index pour accélérer les requêtes fréquentes
        // String[] indexes = {
        //     // Index sur transaction_time pour accélérer les nettoyages
        //     "CREATE INDEX IF NOT EXISTS " + tablePrefix + "_tx_time_idx ON " 
        //         + tablePrefix + "_transaction_limits (transaction_time)",
            
        //     // Index sur player_uuid pour accélérer les requêtes par joueur
        //     "CREATE INDEX IF NOT EXISTS " + tablePrefix + "_player_idx ON " 
        //         + tablePrefix + "_transaction_limits (player_uuid)",
            
        //     // Index composite pour les requêtes de récapitulation
        //     "CREATE INDEX IF NOT EXISTS " + tablePrefix + "_lookup_idx ON " 
        //         + tablePrefix + "_transaction_limits (player_uuid, shop_id, item_id, transaction_type)"
        // };
        
        // for (String indexQuery : indexes) {
        //     try {
        //         plugin.getDataManager().executeUpdate(indexQuery);
        //     } catch (Exception e) {
        //         plugin.getLogger().warning("Erreur lors de la création d'index: " + e.getMessage());
        //     }
        // }
        
        // Créer toutes les tables nécessaires
        createTransactionTables();
    }

    /**
     * Crée toutes les tables nécessaires pour le système de limites de transactions.
     * Compatible avec MySQL et SQLite.
     */
    private void createTransactionTables() {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        boolean isMySQL = plugin.getDataConfig().getDatabaseType().equalsIgnoreCase("mysql");
        // boolean isSQLite = plugin.getDataConfig().getDatabaseType().equalsIgnoreCase("sqlite");
        
        // Structure de base d'une table de transactions
        String baseTableStructure =
                "player_uuid VARCHAR(36) NOT NULL, " +
                "shop_id VARCHAR(100) NOT NULL, " +
                "item_id VARCHAR(100) NOT NULL, " +
                // "transaction_type ENUM('BUY', 'SELL') NOT NULL, " + 
                "transaction_type VARCHAR(10) NOT NULL, " + 
                "amount INT NOT NULL, " +
                "transaction_time TIMESTAMP NOT NULL, " +
                // "transaction_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, " +
                "PRIMARY KEY (player_uuid, shop_id, item_id, transaction_type, transaction_time)";
        
        // Tableau des tables à créer
        String[] tablesToCreate = {
            tablePrefix + "_transaction_limits",  // Table principale
            tablePrefix + "_tx_daily",            // Limites quotidiennes
            tablePrefix + "_tx_weekly",           // Limites hebdomadaires
            tablePrefix + "_tx_monthly",          // Limites mensuelles
            tablePrefix + "_tx_yearly",           // Limites annuelles
            tablePrefix + "_tx_forever"           // Limites permanentes
        };
        
        for (String tableName : tablesToCreate) {
            if (isMySQL && !tableName.equals(tablePrefix + "_transaction_limits")) {
                // Avec MySQL, on peut utiliser LIKE pour les tables secondaires

                String query = "CREATE TABLE IF NOT EXISTS " + tableName + " LIKE " + tablePrefix + "_transaction_limits";
                plugin.getDataManager().executeUpdate(query);
            } else {
                // Création complète de la structure pour SQLite ou la table principale MySQL
                String query = "CREATE TABLE IF NOT EXISTS " + tableName + " (" + baseTableStructure + ")";
                plugin.getDataManager().executeUpdate(query);
            }
        }
        
        // Création des index pour chaque table
        for (String tableName : tablesToCreate) {
            createIndexesForTable(tableName);
        }
        
        // Création de la vue (pour MySQL uniquement)
        if (isMySQL) {
            createTransactionsView(tablePrefix, tablesToCreate);
        // } else {
        //     // Pour SQLite, on n'utilise pas de vue, mais on peut créer une table de transactions globale
        //     String query = "CREATE TABLE IF NOT EXISTS " + tablePrefix + "_transactions AS SELECT * FROM " + tablePrefix + "_transaction_limits WHERE 1=0";
        //     plugin.getDataManager().executeUpdate(query);
        }
    }

    /**
     * Crée les index nécessaires pour une table de transactions
     */
    private void createIndexesForTable(String tableName) {
        boolean isMysql = plugin.getDataConfig().getDatabaseType().equals("mysql");
        
        if (isMysql) {
            // Syntaxe MySQL
            String[] indexes = {
                "CREATE INDEX IF NOT EXISTS " + tableName + "_time_idx ON " + tableName + " (transaction_time)",
                "CREATE INDEX IF NOT EXISTS " + tableName + "_player_idx ON " + tableName + " (player_uuid)",
                "CREATE INDEX IF NOT EXISTS " + tableName + "_lookup_idx ON " + tableName + " (player_uuid, shop_id, item_id, transaction_type)"
            };
            
            for (String indexQuery : indexes) {
                try {
                    plugin.getDataManager().executeUpdate(indexQuery);
                } catch (Exception e) {
                    plugin.getLogger().warning("Erreur lors de la création d'index pour " + tableName + ": " + e.getMessage());
                }
            }
        } else {
            // Syntaxe SQLite - créer les index un par un avec des noms plus simples
            try {
                plugin.getDataManager().executeUpdate("CREATE INDEX IF NOT EXISTS " + tableName + "_time_idx ON " + tableName + " (transaction_time)");

                plugin.getDataManager().executeUpdate("CREATE INDEX IF NOT EXISTS " + tableName + "_player_idx ON " + tableName + " (player_uuid)");

                plugin.getDataManager().executeUpdate("CREATE INDEX IF NOT EXISTS " + tableName + "_lookup_idx ON " + tableName + " (player_uuid, shop_id, item_id, transaction_type)");
            } catch (Exception e) {
                plugin.getLogger().warning("Erreur lors de la création d'index SQLite pour " + tableName + ": " + e.getMessage());
            }
        }
    }

    // /**
    //  * Crée une vue qui combine toutes les tables de transactions (MySQL uniquement)
    //  */
    // private void createTransactionsView(String tablePrefix, String[] tables) {
    //     try {
    //         StringBuilder viewQuery = new StringBuilder();
    //         viewQuery.append("CREATE OR REPLACE VIEW ").append(tablePrefix).append("_transactions_view AS ");
            
    //         for (int i = 0; i < tables.length; i++) {
    //             if (i > 0) {
    //                 viewQuery.append(" UNION ALL ");
    //             }
    //             viewQuery.append("SELECT * FROM ").append(tables[i]);
    //         }
            
    //         plugin.getDataManager().executeUpdate(viewQuery.toString());
    //     } catch (Exception e) {
    //         // Si la vue ne peut pas être créée, on continue sans erreur critique
    //         plugin.getLogger().warning("Note: Impossible de créer la vue de transactions: " + e.getMessage());
    //     }
    // }
    /**
     * Crée une vue qui combine toutes les tables de transactions (compatible MySQL et SQLite)
     */
    private void createTransactionsView(String tablePrefix, String[] tables) {
        try {
            // Vérifier si nous utilisons MySQL ou SQLite
            boolean isMysql = plugin.getDataConfig().getDatabaseType().equals("mysql");
            
            // Supprimer la vue existante si elle existe
            plugin.getDataManager().executeUpdate("DROP VIEW IF EXISTS " + tablePrefix + "_transactions_view");
            
            // Construction de la requête SQL pour créer la vue
            StringBuilder viewSQL = new StringBuilder();
            viewSQL.append("CREATE ");
            if (!isMysql) {
                // SQLite n'a pas de "OR REPLACE"
                viewSQL.append("VIEW ");
            } else {
                // MySQL permet "OR REPLACE"
                viewSQL.append("OR REPLACE VIEW ");
            }
            viewSQL.append(tablePrefix).append("_transactions_view AS ");
            
            for (int i = 0; i < tables.length; i++) {
                if (i > 0) viewSQL.append(" UNION ALL ");
                viewSQL.append("SELECT * FROM ").append(tables[i]);
            }
            
            // Exécuter la requête SQL
            plugin.getDataManager().executeUpdate(viewSQL.toString());
            
        } catch (Exception e) {
            // Message d'erreur plus informatif
            plugin.getLogger().warning("Note: Impossible de créer la vue des transactions (" + 
                                    (plugin.getDataConfig().getDatabaseType().equals("mysql") ? "MySQL" : "SQLite") + 
                                    "): " + e.getMessage());
        }
    }
    
    public void recordTransaction(Player player, String shopId, String itemId, boolean isBuy, int amount) {
        // Vérifier si nous sommes en mode FLATFILE
        if (plugin.getDataConfig().getDatabaseType().equals("flatfile")) {
            // Utiliser le gestionnaire de fichiers plats au lieu de SQL
            if (plugin.getFlatFileManager() != null) {
                plugin.getFlatFileManager().getTransactionManager().addTransaction(player.getUniqueId(), shopId, itemId, isBuy, amount);
            }
            return;
        }

        // String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        // String query = "INSERT INTO " + tablePrefix + "_transaction_limits "
        //         + "(player_uuid, shop_id, item_id, transaction_type, amount, transaction_time) "
        //         + "VALUES (?, ?, ?, ?, ?, NOW())";
            // Déterminer quelle table utiliser en fonction de la période
        LimitCacheEntry limit = getTransactionLimit(player, shopId, itemId, isBuy);

        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        String tableName = tablePrefix + "_transaction_limits"; // Table par défaut
        
        if (limit != null) {
            // Déterminer la table à utiliser en fonction du cooldown
            LimitPeriod equivalentPeriod = limit.getPeriodEquivalent();
            // Sélectionner la table partitionnée appropriée
            switch (equivalentPeriod) {
                case DAILY:
                    tableName = tablePrefix + "_tx_daily";
                    break;
                case WEEKLY:
                    tableName = tablePrefix + "_tx_weekly";
                    break;
                case MONTHLY:
                    tableName = tablePrefix + "_tx_monthly";
                    break;
                case YEARLY:
                    tableName = tablePrefix + "_tx_yearly";
                    break;
                case FOREVER:
                    tableName = tablePrefix + "_tx_forever";
                    break;
                case NONE:
                default:
                    tableName = tablePrefix + "_transaction_limits"; // Table principale
                    break;
            }
        }

        // Créer une copie finale de tableName pour utilisation dans la lambda
        final String finalTableName = tableName;
        boolean isMysql = plugin.getDataConfig().getDatabaseType().equals("mysql");
        String transactionType = isBuy ? "BUY" : "SELL";

        // Incrémenter métriques
        incrementCounter("total_transactions");
        incrementCounter(isBuy ? "buy_transactions" : "sell_transactions");
        // incrementCounter("shop_" + shopId + "_transactions");
        // incrementCounter("item_" + itemId + "_transactions");
        // incrementCounter("player_" + player.getUniqueId() + "_transactions");
        
        // Réinitialiser les métriques quotidiennes si nécessaire
        long now = System.currentTimeMillis();
        if (now - lastMetricsReset > 24 * 60 * 60 * 1000) { // 24 heures
            transactionCounters.clear();
            lastMetricsReset = now;
        }
        
        plugin.getDataManager().executeAsync(() -> {
            try (Connection connection = plugin.getDataManager().getConnection()) {
                // Reste de votre code existant en utilisant tableName au lieu de tablePrefix + "_transaction_limits"
                // Utiliser INSERT ... ON DUPLICATE KEY UPDATE pour éviter les doublons
                String query = "INSERT INTO " + finalTableName + " "
                        + "(player_uuid, shop_id, item_id, transaction_type, amount, transaction_time) "
                        + "VALUES (?, ?, ?, ?, ?, NOW()) "
                        + "ON DUPLICATE KEY UPDATE amount = amount + ?, transaction_time = NOW()";

                // try (PreparedStatement stmt = connection.prepareStatement(query)) {
                //     stmt.setString(1, player.getUniqueId().toString());
                //     stmt.setString(2, shopId);
                //     stmt.setString(3, itemId);
                //     stmt.setString(4, transactionType);
                //     stmt.setInt(5, amount);
                //     stmt.setInt(6, amount);
                
                //     // Exécuter la requête et retourner le nombre de lignes affectées
                //     int result = stmt.executeUpdate();
                    
                //     // Si transaction réussie, vérifier si un nettoyage est nécessaire
                //     if (result > 0 && Math.random() < 0.01) { // 1% de chance de déclencher un nettoyage
                //     // if (result > 0) {
                //         cleanupExpiredTransactions();
                //     }
                    
                //     return result;
                // }
                return plugin.getDataManager().executeUpdate(query,
                    player.getUniqueId().toString(),
                    shopId,
                    itemId,
                    transactionType,
                    amount,
                    amount
                );
            } catch (SQLException e) {
                // Si l'erreur est due à une syntaxe ON DUPLICATE KEY non supportée (SQLite)
                // if (e.getMessage().contains("syntax error") && e.getMessage().contains("ON DUPLICATE KEY")) {
                    // Essayer l'approche alternative pour SQLite
                // }
                plugin.getLogger().severe("Erreur lors de l'enregistrement d'une transaction: " + e.getMessage());
                return 0;
            }
        });
    }

    public boolean canPerformTransactionSync(Player player, String shopId, String itemId, boolean isBuy, int amount) {
        LimitCacheEntry entry = getTransactionLimit(player, shopId, itemId, isBuy);
        if (entry == null) {
            return true; // Pas de limite définie
        }
        
        // Nettoyer les entrées obsolètes d'abord
        String transactionType = isBuy ? "BUY" : "SELL";
        cleanFutureTimestamps(player, shopId, itemId, transactionType);
        clearExpiredTimestamps(player, shopId, itemId, transactionType);

        // Vérifier si la limite est respectée
        return entry.remaining >= amount;
    }

    // private LocalDateTime getStartDateForPeriod(LimitPeriod period) {
    //     LocalDateTime now = LocalDateTime.now();
        
    //     switch (period) {
    //         case DAILY:
    //             return now.truncatedTo(ChronoUnit.DAYS);
    //         case WEEKLY:
    //             return now.with(TemporalAdjusters.previousOrSame(java.time.DayOfWeek.MONDAY)).truncatedTo(ChronoUnit.DAYS);
    //         case MONTHLY:
    //             return now.withDayOfMonth(1).truncatedTo(ChronoUnit.DAYS);
    //         case YEARLY:
    //             return now.withDayOfYear(1).truncatedTo(ChronoUnit.DAYS);
    //         case FOREVER:
    //             return LocalDateTime.ofEpochSecond(0, 0, ZoneId.systemDefault().getRules().getOffset(now));
    //         case NONE:
    //         default:
    //             return now; // Pas de période, donc on utilise maintenant
    //     }
    // }
    private LocalDateTime getStartDateForPeriod(LimitPeriod period) {
        // CORRECTION: Utiliser la date actuelle correcte et non une date future
        LocalDateTime now = LocalDateTime.now();
        
        switch (period) {
            case DAILY:
                // Début de la journée actuelle
                return now.withHour(0).withMinute(0).withSecond(0).withNano(0);
            case WEEKLY:
                // Début de la semaine actuelle (lundi)
                return now.with(TemporalAdjusters.previousOrSame(java.time.DayOfWeek.MONDAY))
                    .withHour(0).withMinute(0).withSecond(0).withNano(0);
            case MONTHLY:
                // Début du mois actuel
                return now.withDayOfMonth(1)
                    .withHour(0).withMinute(0).withSecond(0).withNano(0);
            case YEARLY:
                // Début de l'année actuelle
                return now.withDayOfYear(1)
                    .withHour(0).withMinute(0).withSecond(0).withNano(0);
            case FOREVER:
                // Une date très ancienne
                return LocalDateTime.of(2000, 1, 1, 0, 0);
            case NONE:
            default:
                // Par défaut, retourner l'instant actuel
                return now;
        }
    }
    
    public int getRemainingAmountSync(Player player, String shopId, String itemId, boolean isBuy) {
        // Vérifier si nous sommes en mode FLATFILE
        if (plugin.getDataConfig().getDatabaseType().equals("flatfile")) {
            // Utiliser le gestionnaire de fichiers plats
            if (plugin.getFlatFileManager() != null) {
                LimitCacheEntry entry = getTransactionLimit(player, shopId, itemId, isBuy);
                if (entry == null || entry.baseLimit <= 0) {
                    return Integer.MAX_VALUE;
                }
                return entry.remaining;
            }
            return Integer.MAX_VALUE; // Valeur par défaut si le gestionnaire n'est pas disponible
        }
        
        // Clé de cache standardisée
        final String cacheKey = DynaShopPlugin.getLimitCacheKey(player.getUniqueId(), shopId, itemId, isBuy);
        
        // Vérifier si l'entrée est dans le cache
        LimitCacheEntry entry = plugin.getLimitCache().getIfPresent(cacheKey);
        if (entry != null) {
            return entry.remaining;
        }
        
        // Sinon, charger les limites complètes (ce qui va aussi calculer remaining)
        entry = getTransactionLimit(player, shopId, itemId, isBuy);
        if (entry == null) {
            return Integer.MAX_VALUE; // Pas de limite
        }
        
        return entry.remaining;
    }


    /**
     * Calcule la quantité restante pour une limite donnée
     */
    private int getRemainingAmountSync(Player player, String shopId, String itemId, boolean isBuy, int amount, int cooldown) {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        String transactionType = isBuy ? "BUY" : "SELL";
        
        // Déterminer la période équivalente
        LimitPeriod period = getPeriodForCooldown(cooldown);
        
        // Déterminer la date de début
        LocalDateTime startDate;
        if (period != LimitPeriod.NONE) {
            startDate = getStartDateForPeriod(period);
        } else {
            startDate = LocalDateTime.now().minusSeconds(cooldown);
        }
        
        // Exécuter la requête appropriée
        boolean isMysql = plugin.getDataConfig().getDatabaseType().equals("mysql");
        String query;
        Object[] params;
        
        if (isMysql) {
            query = "SELECT COALESCE(SUM(amount), 0) as total FROM " + tablePrefix + "_transactions_view " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                    "AND transaction_time >= ?";
            params = new Object[] {
                player.getUniqueId().toString(),
                shopId,
                itemId,
                transactionType,
                java.sql.Timestamp.valueOf(startDate)
            };
        } else {
            query = "SELECT COALESCE(SUM(amount), 0) as total FROM (" +
                    "SELECT amount FROM " + tablePrefix + "_tx_daily " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? AND transaction_time >= ? " +
                    "UNION ALL SELECT amount FROM " + tablePrefix + "_tx_weekly " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? AND transaction_time >= ? " +
                    "UNION ALL SELECT amount FROM " + tablePrefix + "_tx_monthly " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? AND transaction_time >= ? " +
                    "UNION ALL SELECT amount FROM " + tablePrefix + "_tx_yearly " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? AND transaction_time >= ? " +
                    "UNION ALL SELECT amount FROM " + tablePrefix + "_tx_forever " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? AND transaction_time >= ? " +
                    "UNION ALL SELECT amount FROM " + tablePrefix + "_transaction_limits " +
                    "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? AND transaction_time >= ?)";
            
            params = new Object[30];
            for (int i = 0; i < 6; i++) {
                int offset = i * 5;
                params[offset] = player.getUniqueId().toString();
                params[offset + 1] = shopId;
                params[offset + 2] = itemId;
                params[offset + 3] = transactionType;
                params[offset + 4] = java.sql.Timestamp.valueOf(startDate);
            }
        }
        
        return plugin.getDataManager().executeQuery(query, rs -> {
            if (rs.next()) {
                int currentTotal = rs.getInt("total");
                return Math.max(0, amount - currentTotal);
            }
            return amount;
        }, params).orElse(amount);
    }


    public long getNextAvailableTimeSync(Player player, String shopId, String itemId, boolean isBuy) {
        // Clé de cache standardisée
        final String cacheKey = DynaShopPlugin.getLimitCacheKey(player.getUniqueId(), shopId, itemId, isBuy);
        
        // Vérifier si l'entrée est dans le cache
        LimitCacheEntry entry = plugin.getLimitCache().getIfPresent(cacheKey);
        if (entry != null) {
            return entry.nextAvailable;
        }
        
        // Sinon, charger les limites complètes (ce qui va aussi calculer nextAvailable)
        entry = getTransactionLimit(player, shopId, itemId, isBuy);
        if (entry == null) {
            return 0L; // Pas de limite
        }
        
        return entry.nextAvailable;
    }

    
    /**
     * Calcule le temps avant la prochaine disponibilité
     */
    private long calculateNextAvailableTime(Player player, String shopId, String itemId, boolean isBuy, int cooldown) {
        // Déterminer la période équivalente
        LimitPeriod period = getPeriodForCooldown(cooldown);
        
        // Pour les périodes prédéfinies, calculer le prochain reset
        if (period != LimitPeriod.NONE) {
            LocalDateTime now = LocalDateTime.now();
            LocalDateTime nextReset;
            
            switch (period) {
                case DAILY:
                    nextReset = now.withHour(0).withMinute(0).withSecond(0).withNano(0).plusDays(1);
                    break;
                case WEEKLY:
                    nextReset = now.with(TemporalAdjusters.next(java.time.DayOfWeek.MONDAY))
                        .withHour(0).withMinute(0).withSecond(0).withNano(0);
                    break;
                case MONTHLY:
                    nextReset = now.withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0).withNano(0).plusMonths(1);
                    break;
                case YEARLY:
                    nextReset = now.withDayOfYear(1).withHour(0).withMinute(0).withSecond(0).withNano(0).plusYears(1);
                    break;
                case FOREVER:
                    return -1L; // Pas de reset pour FOREVER
                default:
                    nextReset = now;
                    break;
            }
            
            return nextReset.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() - System.currentTimeMillis();
        }
        
        // Pour les cooldowns normaux, chercher la dernière transaction
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        String transactionType = isBuy ? "BUY" : "SELL";
        
        boolean isMysql = plugin.getDataConfig().getDatabaseType().equals("mysql");
        String query;
        
        if (isMysql) {
            query = "SELECT MIN(transaction_time) as earliest FROM " + tablePrefix + "_transactions_view " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ?";
        } else {
            query = "SELECT MIN(transaction_time) as earliest FROM (" +
                "SELECT transaction_time FROM " + tablePrefix + "_tx_daily " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_weekly " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_monthly " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_yearly " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_forever " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_transaction_limits " +
                "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ?)";
        }
        
        try (Connection connection = plugin.getDataManager().getConnection();
            PreparedStatement stmt = connection.prepareStatement(query)) {
            
            stmt.setString(1, player.getUniqueId().toString());
            stmt.setString(2, shopId);
            stmt.setString(3, itemId);
            stmt.setString(4, transactionType);
            
            if (!isMysql) {
                for (int i = 1; i < 6; i++) {
                    int offset = i * 4;
                    stmt.setString(offset + 1, player.getUniqueId().toString());
                    stmt.setString(offset + 2, shopId);
                    stmt.setString(offset + 3, itemId);
                    stmt.setString(offset + 4, transactionType);
                }
            }
            
            ResultSet rs = stmt.executeQuery();
            if (rs.next() && rs.getTimestamp("earliest") != null) {
                java.sql.Timestamp earliestTime = rs.getTimestamp("earliest");
                
                long now = System.currentTimeMillis();
                LocalDateTime nextAvailableTime = earliestTime.toLocalDateTime().plusSeconds(cooldown);
                long nextAvailable = nextAvailableTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() - now;
                return Math.max(0, nextAvailable);
            }
        } catch (SQLException e) {
            plugin.getLogger().warning("Erreur SQL dans calculateNextAvailableTime: " + e.getMessage());
        }
        
        return 0L;
    }

    /**
     * Détermine la période équivalente pour un cooldown donné
     */
    private LimitPeriod getPeriodForCooldown(int cooldown) {
        if (cooldown >= 31536000) return LimitPeriod.FOREVER;
        if (cooldown >= 2592000) return LimitPeriod.MONTHLY;
        if (cooldown >= 604800) return LimitPeriod.WEEKLY;
        if (cooldown >= 86400) return LimitPeriod.DAILY;
        return LimitPeriod.NONE;
    }

    // limit:
    //     sell: 100  # Nombre maximum d'items vendables
    //     buy: 100   # Nombre maximum d'items achetables
    //     cooldown: 3600  # Soit en secondes (exemple: 3600 pour 1 heure)
    //     # OU
    //     # cooldown: DAILY  # Période prédéfinie (DAILY, WEEKLY, MONTHLY, YEARLY, FOREVER)
    
    /**
     * Obtient les limites de transaction pour un item spécifique
     * Optimisé pour utiliser le cache interne du plugin
     */
    public LimitCacheEntry getTransactionLimit(Player player, String shopId, String itemId, boolean isBuy) {
        // Désactiver les limites si SQLite
        if (plugin.getDataConfig().getDatabaseType().equalsIgnoreCase("sqlite")) {
            return null;
        }
        // Clé de cache standardisée
        // final String cacheKey = shopId + ":" + itemId + ":" + (isBuy ? "buy" : "sell") + ":limit";
        final String cacheKey = DynaShopPlugin.getLimitCacheKey(player.getUniqueId(), shopId, itemId, isBuy);
        
        // Utiliser le cache intégré du plugin
        return plugin.getLimitCache().get(cacheKey, () -> {
            try {
                // Si l'item n'est pas dans le cache, charger depuis la config
                String limitPath = isBuy ? "limit.buy" : "limit.sell";
                int amount = plugin.getShopConfigManager().getItemValue(shopId, itemId, limitPath, Integer.class).orElse(0);
                
                if (amount <= 0) {
                    // Pas de limite - retourner null mais garder en cache pour éviter des recherches répétées
                    // plugin.getLogger().info("Aucune limite définie pour " + shopId + ":" + itemId + " (" + limitPath + ")");
                    return null;
                }
                // plugin.getLogger().info("Limite trouvée pour " + shopId + ":" + itemId + " (" + limitPath + "): " + amount);
                
                // Traiter le cooldown (peut être un nombre ou une période)
                int cooldownSeconds = 0;
                
                // Essayer d'abord comme un entier
                Optional<Integer> cooldownInt = plugin.getShopConfigManager().getItemValue(shopId, itemId, "limit.cooldown", Integer.class);
                if (cooldownInt.isPresent()) {
                    cooldownSeconds = cooldownInt.get();
                    // plugin.getLogger().info("Cooldown trouvé pour " + shopId + ":" + itemId + " (" + limitPath + "): " + cooldownSeconds);
                } else {
                    // Essayer comme une chaîne (période ou nombre en texte)
                    Optional<String> cooldownStr = plugin.getShopConfigManager().getItemValue(shopId, itemId, "limit.cooldown", String.class);
                    if (cooldownStr.isPresent()) {
                        String periodStr = cooldownStr.get().toUpperCase();
                        
                        try {
                            // Essayer comme période prédéfinie (DAILY, WEEKLY, etc.)
                            LimitPeriod period = LimitPeriod.valueOf(periodStr);
                            cooldownSeconds = period.getSeconds();
                        } catch (IllegalArgumentException e) {
                            // Essayer comme nombre en texte
                            try {
                                cooldownSeconds = Integer.parseInt(periodStr);
                            } catch (NumberFormatException ex) {
                                cooldownSeconds = 0;
                            }
                        }
                    }
                }
                
                // Calculer remaining et nextAvailable ici
                int remaining = getRemainingAmountSync(player, shopId, itemId, isBuy, amount, cooldownSeconds);
                long nextAvailable = calculateNextAvailableTime(player, shopId, itemId, isBuy, cooldownSeconds);
                
                // Créer et retourner la limite (sera mise en cache automatiquement)
                return new LimitCacheEntry(player.getUniqueId(), shopId, itemId, isBuy, amount, cooldownSeconds, remaining, nextAvailable);

            } catch (Exception e) {
                plugin.getLogger().severe("Erreur lors de la récupération des limites pour " + shopId + ":" + itemId + ": " + e.getMessage());
                return null;
            }
        });
    }

    public CompletableFuture<Long> getNextAvailableTime(Player player, String shopId, String itemId, boolean isBuy) {
        LimitCacheEntry limit = getTransactionLimit(player, shopId, itemId, isBuy);
        if (limit == null || limit.getCooldown() <= 0) {
            return CompletableFuture.completedFuture(0L);
        }
        
        LimitPeriod period = limit.getPeriodEquivalent();
        
        // Pour les périodes prédéfinies (DAILY, WEEKLY, etc.), calculer la fin de la période actuelle
        // if (period != LimitPeriod.NONE && period != LimitPeriod.FOREVER) {
        if (period != LimitPeriod.NONE) {
            LocalDateTime now = LocalDateTime.now();
            LocalDateTime nextReset;
            
            switch (period) {
                case DAILY:
                    // Prochain reset à minuit
                    nextReset = now.withHour(0).withMinute(0).withSecond(0).withNano(0).plusDays(1);
                    break;
                case WEEKLY:
                    // Prochain reset lundi prochain à minuit
                    nextReset = now.with(TemporalAdjusters.next(java.time.DayOfWeek.MONDAY))
                        .withHour(0).withMinute(0).withSecond(0).withNano(0);
                    if (now.getDayOfWeek() == java.time.DayOfWeek.MONDAY && now.getHour() == 0 && now.getMinute() == 0) {
                        // Si c'est déjà lundi à minuit, on est déjà réinitialisé
                        return CompletableFuture.completedFuture(0L);
                    }
                    break;
                case MONTHLY:
                    // Prochain reset au 1er du mois prochain
                    nextReset = now.withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0).withNano(0).plusMonths(1);
                    break;
                case YEARLY:
                    // Prochain reset au 1er janvier prochain
                    nextReset = now.withDayOfYear(1).withHour(0).withMinute(0).withSecond(0).withNano(0).plusYears(1);
                    break;
                case FOREVER:
                    // Pas de reset, donc on retourne -1
                    return CompletableFuture.completedFuture(-1L);
                // case NONE:
                default:
                    nextReset = now; // Ne devrait jamais arriver
                    break;
            }
            
            long nextResetMillis = nextReset.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
            long nowMillis = System.currentTimeMillis();
            
            // Calculer le temps restant jusqu'au prochain reset
            return CompletableFuture.completedFuture(Math.max(0, nextResetMillis - nowMillis));
        }
        
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        String transactionType = isBuy ? "BUY" : "SELL";
        
        // // long now = System.currentTimeMillis();
        // LocalDateTime now = LocalDateTime.now();
        // LocalDateTime startDate;
        // if (limit.getPeriodEquivalent() != LimitPeriod.NONE) {
        //     // Pour les périodes prédéfinies, utiliser la date de début de la période
        //     startDate = getStartDateForPeriod(limit.getPeriodEquivalent());
        //     if (startDate.getDayOfWeek() == DayOfWeek.MONDAY && now.getHour() == 0 && now.getMinute() == 0) {
        //         return CompletableFuture.completedFuture(0L);
        //     }
        // } else {
        //     // Pour les cooldowns en secondes, calculer la date à partir du moment actuel
        //     startDate = LocalDateTime.now().minusSeconds(limit.getCooldown());
        // }

        // long nowMillis = System.currentTimeMillis();
        // long startTimeMillis = startDate.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
        // if (startTimeMillis > nowMillis) {
        //     // Si la date de début est dans le futur, retourner 0 (disponible immédiatement)
        //     return CompletableFuture.completedFuture(0L);
        // }


        boolean isMysql = plugin.getDataConfig().getDatabaseType().equals("mysql");
        String query;
        if (isMysql) {
            query = "SELECT MIN(transaction_time) as earliest FROM " + tablePrefix + "_transactions_view "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ?";
        } else {
            query = "SELECT MIN(transaction_time) as earliest FROM ("
                    + "SELECT transaction_time FROM " + tablePrefix + "_tx_daily "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? "
                    + "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_weekly "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? "
                    + "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_monthly "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? "
                    + "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_yearly "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? "
                    + "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_tx_forever "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? "
                    + "UNION ALL SELECT transaction_time FROM " + tablePrefix + "_transaction_limits "
                    + "WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ?) AS combined";
        }

        return plugin.getDataManager().executeAsync(() -> {
            try (Connection connection = plugin.getDataManager().getConnection();
                 PreparedStatement stmt = connection.prepareStatement(query)) {
                stmt.setString(1, player.getUniqueId().toString());
                stmt.setString(2, shopId);
                stmt.setString(3, itemId);
                stmt.setString(4, transactionType);
                
                ResultSet rs = stmt.executeQuery();
                if (rs.next() && rs.getTimestamp("earliest") != null) {
                    java.sql.Timestamp earliestTime = rs.getTimestamp("earliest");
                    
                    // Vérifier si l'horodatage est dans le futur
                    long now = System.currentTimeMillis();
                    // long earliestTimeMillis = earliestTime.getTime();
                    
                    // if (earliestTimeMillis > now) {
                    //     // plugin.getLogger().warning("Détection d'un horodatage futur pour " + player.getName() + 
                    //     //                     " sur " + shopId + ":" + itemId + " - Réinitialisation forcée");
                        
                    //     // Corriger en supprimant les entrées avec horodatages futurs
                    //     resetFutureTimestamps(player.getUniqueId(), shopId, itemId, transactionType);
                        
                    //     // Disponible immédiatement
                    //     return 0L;
                    // }
                    
                    // Calculer le temps jusqu'à la prochaine disponibilité
                    LocalDateTime nextAvailable = earliestTime.toLocalDateTime().plusSeconds(limit.getCooldown());
                    long nextTimeMillis = nextAvailable.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
                    
                    // Si le temps est déjà passé, retourner 0 (disponible immédiatement)
                    return Math.max(0L, nextTimeMillis - now);
                }
                return 0L;
            }
        });
    }


    private void clearExpiredTimestamps(Player player, String shopId, String itemId, String transactionType) {
        // plugin.getLogger().info("Nettoyage des horodatages périmés pour " + player.getUniqueId() + " sur " + shopId + ":" + itemId);
        LimitCacheEntry limit = getTransactionLimit(player, shopId, itemId, transactionType.equals("BUY"));
        if (limit == null) {
            // plugin.getLogger().info("Aucune limite trouvée pour " + player.getUniqueId() + " sur " + shopId + ":" + itemId);
            return;
        }
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        String[] tables = {
            tablePrefix + "_tx_daily",
            tablePrefix + "_tx_weekly",
            tablePrefix + "_tx_monthly",
            tablePrefix + "_tx_yearly",
            tablePrefix + "_tx_forever",
            tablePrefix + "_transaction_limits"
        };
        
        // Déterminer la date de début en fonction de la période ou du cooldown
        LocalDateTime startDate;
        if (limit.getPeriodEquivalent() != LimitPeriod.NONE) {
            // Pour les périodes prédéfinies, utiliser la date de début de la période
            startDate = getStartDateForPeriod(limit.getPeriodEquivalent());
        } else {
            // Pour les cooldowns en secondes, calculer la date à partir du moment actuel
            startDate = LocalDateTime.now().minusSeconds(limit.getCooldown());
        }

        // plugin.getLogger().info("Date de début pour le nettoyage: " + startDate);
        for (String table : tables) {
            String query = "DELETE FROM " + table + 
                        " WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                        " AND transaction_time < ?";

            // plugin.getLogger().info("Suppression des entrées périmées pour la table " + table + 
            //                     " pour le joueur " + playerUuid + 
            //                     " sur le shop " + shopId + 
            //                     " et l'item " + itemId);
            
            plugin.getDataManager().executeAsync(() -> {
                try (Connection connection = plugin.getDataManager().getConnection();
                    PreparedStatement stmt = connection.prepareStatement(query)) {
                    stmt.setString(1, player.getUniqueId().toString());
                    stmt.setString(2, shopId);
                    stmt.setString(3, itemId);
                    stmt.setString(4, transactionType);
                    stmt.setTimestamp(5, java.sql.Timestamp.valueOf(startDate));
                    
                    return stmt.executeUpdate();
                } catch (SQLException e) {
                    plugin.getLogger().severe("Erreur lors de la suppression d'entrées périmées: " + e.getMessage());
                    return 0;
                }
            });
        }
    }
    
    // Nouvelle méthode pour nettoyer les horodatages futurs
    private void cleanFutureTimestamps(Player player, String shopId, String itemId, String transactionType) {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        String[] tables = {
            tablePrefix + "_tx_daily",
            tablePrefix + "_tx_weekly",
            tablePrefix + "_tx_monthly",
            tablePrefix + "_tx_yearly",
            tablePrefix + "_tx_forever",
            tablePrefix + "_transaction_limits"
        };
        
        // Obtenir la date/heure actuelle
        long currentTimeMillis = System.currentTimeMillis();
        java.sql.Timestamp currentTimestamp = new java.sql.Timestamp(currentTimeMillis);
        
        for (String table : tables) {
            String query = "DELETE FROM " + table + 
                        " WHERE player_uuid = ? AND shop_id = ? AND item_id = ? AND transaction_type = ? " +
                        " AND transaction_time > ?";
                        // " AND transaction_time > NOW()";
            
            plugin.getDataManager().executeAsync(() -> {
                try (Connection connection = plugin.getDataManager().getConnection();
                    PreparedStatement stmt = connection.prepareStatement(query)) {
                    stmt.setString(1, player.getUniqueId().toString());
                    stmt.setString(2, shopId);
                    stmt.setString(3, itemId);
                    stmt.setString(4, transactionType);
                    stmt.setTimestamp(5, currentTimestamp);
                    
                    return stmt.executeUpdate();
                } catch (SQLException e) {
                    plugin.getLogger().severe("Erreur lors de la suppression d'entrées futures: " + e.getMessage());
                    return 0;
                }
            });
        }
    }

    /**
     * Nettoie les données de transactions périmées de la base de données.
     * Cette méthode supprime toutes les transactions dont la période est expirée.
     */
    public void cleanupExpiredTransactions() {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        
        // Nettoyer chaque table partitionnée
        for (LimitPeriod period : LimitPeriod.values()) {
            if (period == LimitPeriod.NONE || period == LimitPeriod.FOREVER) {
                continue; // Pas de nettoyage pour ces périodes
            }
            
            LocalDateTime cutoffDate;
            String tableName;
            
            // Déterminer la date limite et la table à nettoyer
            switch (period) {
                case DAILY:
                    cutoffDate = LocalDateTime.now().truncatedTo(ChronoUnit.DAYS);
                    tableName = tablePrefix + "_tx_daily";
                    break;
                case WEEKLY:
                    cutoffDate = LocalDateTime.now().with(TemporalAdjusters.previousOrSame(java.time.DayOfWeek.MONDAY)).truncatedTo(ChronoUnit.DAYS);
                    tableName = tablePrefix + "_tx_weekly";
                    break;
                case MONTHLY:
                    cutoffDate = LocalDateTime.now().withDayOfMonth(1).truncatedTo(ChronoUnit.DAYS);
                    tableName = tablePrefix + "_tx_monthly";
                    break;
                case YEARLY:
                    cutoffDate = LocalDateTime.now().withDayOfYear(1).truncatedTo(ChronoUnit.DAYS);
                    tableName = tablePrefix + "_tx_yearly";
                    break;
                default:
                    continue; // Ignorer les autres périodes
            }
            
            // Effectuer le nettoyage
            final LocalDateTime finalCutoffDate = cutoffDate;
            final String finalTableName = tableName;
            
            plugin.getDataManager().executeAsync(() -> {
                try (Connection connection = plugin.getDataManager().getConnection();
                    PreparedStatement stmt = connection.prepareStatement(
                        "DELETE FROM " + finalTableName + " WHERE transaction_time < ?")) {
                    stmt.setTimestamp(1, java.sql.Timestamp.valueOf(finalCutoffDate));
                    return stmt.executeUpdate();
                } catch (SQLException e) {
                    plugin.getLogger().severe("Erreur lors du nettoyage des transactions " + period.name() + ": " + e.getMessage());
                    return 0;
                }
            });
        }
        
        // Nettoyer aussi la table principale pour compatibilité
        LocalDateTime defaultCutoff = LocalDateTime.now().minusDays(1).truncatedTo(ChronoUnit.DAYS);
        plugin.getDataManager().executeAsync(() -> {
            try (Connection connection = plugin.getDataManager().getConnection();
                PreparedStatement stmt = connection.prepareStatement(
                    "DELETE FROM " + tablePrefix + "_transaction_limits WHERE transaction_time < ?")) {
                stmt.setTimestamp(1, java.sql.Timestamp.valueOf(defaultCutoff));
                return stmt.executeUpdate();
            } catch (SQLException e) {
                plugin.getLogger().severe("Erreur lors du nettoyage de la table principale: " + e.getMessage());
                return 0;
            }
        });
    }
    public CompletableFuture<Boolean> resetLimits(Player player, String shopId, String itemId) {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        
        // Utiliser une CompletableFuture composite pour attendre tous les résultats
        List<CompletableFuture<Boolean>> futures = new ArrayList<>();
        
        // Pour chaque table partitionnée
        String[] tables = {
            tablePrefix + "_tx_daily",
            tablePrefix + "_tx_weekly",
            tablePrefix + "_tx_monthly",
            tablePrefix + "_tx_yearly",
            tablePrefix + "_tx_forever",
            tablePrefix + "_transaction_limits" // Table principale aussi
        };
        
        for (String table : tables) {
            String query = "DELETE FROM " + table + " WHERE player_uuid = ? AND shop_id = ? AND item_id = ?";
            
            // CompletableFuture<Boolean> future = plugin.getDataManager().executeAsync(() -> {
            //     try (Connection connection = plugin.getDataManager().getConnection();
            //         PreparedStatement stmt = connection.prepareStatement(query)) {
            //         stmt.setString(1, player.getUniqueId().toString());
            //         stmt.setString(2, shopId);
            //         stmt.setString(3, itemId);
                    
            //         return stmt.executeUpdate() >= 0;
            //     }
            // });
            CompletableFuture<Boolean> future = plugin.getDataManager().executeAsync(() ->
                plugin.getDataManager().executeUpdate(query,
                    player.getUniqueId().toString(),
                    shopId,
                    itemId
                ) >= 0
            );
            
            futures.add(future);
        }
        
        // Invalider le cache après la réinitialisation
        final String cacheKey = DynaShopPlugin.getLimitCacheKey(player.getUniqueId(), shopId, itemId, true);
        final String cacheKey2 = DynaShopPlugin.getLimitCacheKey(player.getUniqueId(), shopId, itemId, false);
        
        plugin.getLimitCache().invalidate(cacheKey);
        plugin.getLimitCache().invalidate(cacheKey2);
        
        // Combiner tous les résultats
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> futures.stream().allMatch(CompletableFuture::join));
    }

    /**
     * Réinitialise toutes les limites pour un joueur
     * @param playerUuid UUID du joueur
     * @return Un CompletableFuture contenant le nombre d'entrées supprimées
     */
    public CompletableFuture<Integer> resetAllLimits(UUID playerUuid) {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        
        // Liste des tables à nettoyer
        String[] tables = {
            tablePrefix + "_tx_daily",
            tablePrefix + "_tx_weekly",
            tablePrefix + "_tx_monthly",
            tablePrefix + "_tx_yearly",
            tablePrefix + "_tx_forever",
            tablePrefix + "_transaction_limits" // Table principale aussi
        };
        
        // CompletableFuture pour attendre toutes les opérations
        CompletableFuture<Integer> totalDeleted = CompletableFuture.completedFuture(0);
        
        for (String table : tables) {
            String query = "DELETE FROM " + table + " WHERE player_uuid = ?";
            
            CompletableFuture<Integer> tableFuture = plugin.getDataManager().executeAsync(() -> {
                try (Connection connection = plugin.getDataManager().getConnection();
                    PreparedStatement stmt = connection.prepareStatement(query)) {
                    stmt.setString(1, playerUuid.toString());
                    return stmt.executeUpdate();
                }
            });
            
            // Additionner les résultats
            totalDeleted = totalDeleted.thenCombine(tableFuture, Integer::sum);
        }
        
        return totalDeleted;
    }


    // Classe interne pour les enregistrements de transaction en lot
    public static class TransactionRecord {
        public final UUID playerUuid;
        public final String shopId;
        public final String itemId;
        public final boolean isBuy;
        public final int amount;
        
        public TransactionRecord(UUID playerUuid, String shopId, String itemId, boolean isBuy, int amount) {
            this.playerUuid = playerUuid;
            this.shopId = shopId;
            this.itemId = itemId;
            this.isBuy = isBuy;
            this.amount = amount;
        }
    }

    // Méthode pour obtenir des statistiques sur l'utilisation
    public CompletableFuture<Map<String, Object>> getStatistics() {
        String tablePrefix = plugin.getDataConfig().getDatabaseTablePrefix();
        
        return plugin.getDataManager().executeAsync(() -> {
            Map<String, Object> stats = new HashMap<>();
            
            try (Connection connection = plugin.getDataManager().getConnection()) {
                // Total de transactions
                try (PreparedStatement stmt = connection.prepareStatement(
                        "SELECT COUNT(*) AS total FROM " + tablePrefix + "_transaction_limits")) {
                    ResultSet rs = stmt.executeQuery();
                    if (rs.next()) {
                        stats.put("total_records", rs.getInt("total"));
                    }
                }
                
                // Transactions par type
                try (PreparedStatement stmt = connection.prepareStatement(
                        "SELECT transaction_type, COUNT(*) AS count FROM " + tablePrefix + "_transaction_limits " +
                        "GROUP BY transaction_type")) {
                    ResultSet rs = stmt.executeQuery();
                    while (rs.next()) {
                        stats.put("count_" + rs.getString("transaction_type").toLowerCase(), rs.getInt("count"));
                    }
                }
                
                // Plus ancien enregistrement
                try (PreparedStatement stmt = connection.prepareStatement(
                        "SELECT MIN(transaction_time) AS oldest FROM " + tablePrefix + "_transaction_limits")) {
                    ResultSet rs = stmt.executeQuery();
                    if (rs.next() && rs.getTimestamp("oldest") != null) {
                        stats.put("oldest_record", rs.getTimestamp("oldest").toString());
                    }
                }
            } catch (SQLException e) {
                plugin.getLogger().severe("Erreur lors de la récupération des statistiques: " + e.getMessage());
            }
            
            return stats;
        });
    }
}