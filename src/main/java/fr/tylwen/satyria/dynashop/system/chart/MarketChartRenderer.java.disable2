import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.MapMeta;
import org.bukkit.map.MapCanvas;
import org.bukkit.map.MapPalette;
import org.bukkit.map.MapRenderer;
import org.bukkit.map.MapView;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.plugin.Plugin;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class MarketChartRenderer extends MapRenderer {

    private final List<CandleData> candles;
    private final String title;
    private double minPrice;
    private double maxPrice;
    private boolean rendered = false;
    private final Color bullishColor = new Color(0, 200, 0);
    private final Color bearishColor = new Color(255, 0, 0);
    private final Color volumeColor = new Color(100, 100, 180);
    private final Color gridColor = new Color(180, 180, 180);
    private final Color textColor = Color.BLACK;
    
    /**
     * Crée un nouveau renderer de graphique en chandelier
     * 
     * @param title Titre du graphique
     * @param candles Liste des données de chandeliers
     */
    public MarketChartRenderer(String title, List<CandleData> candles) {
        this.title = title;
        this.candles = new ArrayList<>(candles);
        
        // Calcul des valeurs min et max pour l'échelle
        calculateMinMax();
    }
    
    private void calculateMinMax() {
        if (candles.isEmpty()) {
            minPrice = 0;
            maxPrice = 100;
            return;
        }
        
        minPrice = Double.MAX_VALUE;
        maxPrice = Double.MIN_VALUE;
        
        for (CandleData candle : candles) {
            minPrice = Math.min(minPrice, candle.low);
            maxPrice = Math.max(maxPrice, candle.high);
        }
        
        // Ajouter une marge pour une meilleure visualisation
        double range = maxPrice - minPrice;
        minPrice = Math.max(0, minPrice - range * 0.05);
        maxPrice = maxPrice + range * 0.05;
    }

    @Override
    public void render(MapView map, MapCanvas canvas, Player player) {
        // Ne dessiner qu'une seule fois pour éviter les problèmes de performance
        if (rendered) return;
        
        // Effacer la carte
        for (int x = 0; x < 128; x++) {
            for (int y = 0; y < 128; y++) {
                canvas.setPixel(x, y, MapPalette.matchColor(240, 240, 240));
            }
        }
        
        // Dessiner le cadre et la grille
        drawFrame(canvas);
        
        // Dessiner le titre
        drawText(canvas, title, 64, 10, textColor, true);
        
        // Dessiner les prix sur l'axe Y
        drawYAxis(canvas);
        
        // Dessiner les chandeliers
        drawCandles(canvas);
        
        // Dessiner le volume en bas
        drawVolume(canvas);
        
        rendered = true;
    }
    
    private void drawFrame(MapCanvas canvas) {
        // Dessiner le cadre
        for (int x = 10; x < 118; x++) {
            canvas.setPixel(x, 20, MapPalette.matchColor(gridColor));
            canvas.setPixel(x, 90, MapPalette.matchColor(gridColor));
        }
        
        for (int y = 20; y < 91; y++) {
            canvas.setPixel(10, y, MapPalette.matchColor(gridColor));
            canvas.setPixel(117, y, MapPalette.matchColor(gridColor));
        }
        
        // Dessiner quelques lignes de grille horizontales
        for (int i = 1; i < 4; i++) {
            int y = 20 + (i * 70 / 4);
            for (int x = 10; x < 118; x++) {
                if (x % 5 == 0) {
                    canvas.setPixel(x, y, MapPalette.matchColor(new Color(220, 220, 220)));
                }
            }
        }
    }
    
    private void drawYAxis(MapCanvas canvas) {
        // Dessiner les prix sur l'axe Y
        drawText(canvas, String.format("%.1f", maxPrice), 5, 20, textColor, false);
        drawText(canvas, String.format("%.1f", (maxPrice + minPrice) / 2), 5, 55, textColor, false);
        drawText(canvas, String.format("%.1f", minPrice), 5, 90, textColor, false);
    }
    
    private void drawCandles(MapCanvas canvas) {
        int totalCandles = candles.size();
        double priceRange = maxPrice - minPrice;
        
        if (totalCandles == 0 || priceRange == 0) return;
        
        // Largeur disponible pour tous les chandeliers
        int availableWidth = 107; // 117 - 10
        int candleWidth = Math.min(6, availableWidth / totalCandles);
        int spacing = Math.max(1, (availableWidth - (candleWidth * totalCandles)) / Math.max(1, totalCandles - 1));
        
        // Dessiner chaque chandelier
        for (int i = 0; i < totalCandles; i++) {
            CandleData candle = candles.get(i);
            int x = 10 + i * (candleWidth + spacing) + candleWidth / 2;
            
            // Convertir les prix en positions Y
            int openY = 20 + (int)(70 * (1 - (candle.open - minPrice) / priceRange));
            int closeY = 20 + (int)(70 * (1 - (candle.close - minPrice) / priceRange));
            int highY = 20 + (int)(70 * (1 - (candle.high - minPrice) / priceRange));
            int lowY = 20 + (int)(70 * (1 - (candle.low - minPrice) / priceRange));
            
            // Déterminer si c'est un chandelier haussier ou baissier
            boolean isBullish = candle.close >= candle.open;
            Color candleColor = isBullish ? bullishColor : bearishColor;
            
            // Dessiner la mèche
            for (int y = highY; y <= lowY; y++) {
                canvas.setPixel(x, y, MapPalette.matchColor(candleColor));
            }
            
            // Dessiner le corps du chandelier
            int bodyStart = Math.min(openY, closeY);
            int bodyEnd = Math.max(openY, closeY);
            
            for (int bx = x - candleWidth/2; bx <= x + candleWidth/2; bx++) {
                for (int by = bodyStart; by <= bodyEnd; by++) {
                    canvas.setPixel(bx, by, MapPalette.matchColor(candleColor));
                }
            }
        }
    }
    
    private void drawVolume(MapCanvas canvas) {
        int totalCandles = candles.size();
        
        if (totalCandles == 0) return;
        
        // Trouver le volume max
        double maxVolume = 0;
        for (CandleData candle : candles) {
            maxVolume = Math.max(maxVolume, candle.volume);
        }
        
        if (maxVolume == 0) return;
        
        // Largeur disponible pour tous les volumes
        int availableWidth = 107;
        int volumeWidth = Math.min(6, availableWidth / totalCandles);
        int spacing = Math.max(1, (availableWidth - (volumeWidth * totalCandles)) / Math.max(1, totalCandles - 1));
        
        // Dessiner chaque volume
        for (int i = 0; i < totalCandles; i++) {
            CandleData candle = candles.get(i);
            int x = 10 + i * (volumeWidth + spacing) + volumeWidth / 2;
            
            // Hauteur du volume (max 20 pixels)
            int volumeHeight = (int)(20 * candle.volume / maxVolume);
            
            // Dessiner le volume
            for (int vx = x - volumeWidth/2; vx <= x + volumeWidth/2; vx++) {
                for (int vy = 110 - volumeHeight; vy <= 110; vy++) {
                    canvas.setPixel(vx, vy, MapPalette.matchColor(volumeColor));
                }
            }
        }
    }
    
    private void drawText(MapCanvas canvas, String text, int x, int y, Color color, boolean centered) {
        if (centered) {
            x -= text.length() * 2; // Approximation de la largeur du texte
        }
        
        // Méthode simple pour dessiner du texte
        // Note: Dans une implémentation réelle, il faudrait utiliser FontMetrics
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            drawChar(canvas, c, x + i * 4, y, color);
        }
    }
    
    private void drawChar(MapCanvas canvas, char c, int x, int y, Color color) {
        // Implémentation simplifiée pour dessiner un caractère
        // Dans une version réelle, il faudrait une meilleure méthode
        byte colorByte = MapPalette.matchColor(color);
        
        switch (c) {
            // Implémentation basique pour quelques caractères
            case '.':
                canvas.setPixel(x, y, colorByte);
                break;
            case '0':
                for (int i = -1; i <= 1; i++) {
                    canvas.setPixel(x+i, y-1, colorByte);
                    canvas.setPixel(x+i, y+1, colorByte);
                }
                canvas.setPixel(x-1, y, colorByte);
                canvas.setPixel(x+1, y, colorByte);
                break;
            // Ajouter d'autres caractères au besoin...
            default:
                // Dessiner un simple point pour les caractères non supportés
                canvas.setPixel(x, y, colorByte);
                canvas.setPixel(x+1, y, colorByte);
        }
    }
    
    /**
     * Crée une carte avec un graphique en chandelier
     * 
     * @param plugin Plugin instance
     * @param title Titre du graphique
     * @param candles Données des chandeliers
     * @return ItemStack de type FILLED_MAP avec le graphique
     */
    public static ItemStack createCandlestickMap(Plugin plugin, String title, List<CandleData> candles) {
        ItemStack mapItem = new ItemStack(Material.FILLED_MAP);
        MapMeta mapMeta = (MapMeta) mapItem.getItemMeta();
        
        if (mapMeta != null) {
            // Créer une nouvelle vue de carte
            MapView mapView = Bukkit.createMap(Bukkit.getWorlds().get(0));
            
            // Supprimer tous les renderers par défaut
            for (MapRenderer renderer : mapView.getRenderers()) {
                mapView.removeRenderer(renderer);
            }
            
            // Ajouter notre renderer personnalisé
            mapView.addRenderer(new MarketChartRenderer(title, candles));
            
            // Définir les propriétés de la carte
            mapMeta.setMapView(mapView);
            mapMeta.setDisplayName("§6" + title + " Chart");
            mapMeta.setLore(List.of(
                "§7Graphique en chandelier",
                "§7" + candles.size() + " périodes"
            ));
            
            // Ajouter des métadonnées pour identifier cette carte
            // mapMeta.getPersistentDataContainer().set(
            //     plugin.getKey("chart_id"),
            //     PersistentDataType.STRING,
            //     UUID.randomUUID().toString()
            // );
            NamespacedKey shopIdKey = new NamespacedKey(plugin, "chart_shop_id");
            NamespacedKey itemIdKey = new NamespacedKey(plugin, "chart_item_id");
            mapMeta.getPersistentDataContainer().set(shopIdKey, PersistentDataType.STRING, shopId);
            mapMeta.getPersistentDataContainer().set(itemIdKey, PersistentDataType.STRING, itemId);
            
            mapItem.setItemMeta(mapMeta);
        }
        
        return mapItem;
    }
    
    /**
     * Classe pour représenter les données d'un chandelier
     */
    public static class CandleData {
        public final double open;
        public final double high;
        public final double low; 
        public final double close;
        public final double volume;
        
        public CandleData(double open, double high, double low, double close, double volume) {
            this.open = open;
            this.high = high;
            this.low = low;
            this.close = close;
            this.volume = volume;
        }
    }
}