package fr.tylwen.satyria.dynashop.packet;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
// import com.comphenix.protocol.wrappers.WrappedChatComponent;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import fr.tylwen.satyria.dynashop.DynaShopPlugin;
import me.clip.placeholderapi.PlaceholderAPI;
// import net.brcdev.shopgui.ShopGuiPlugin;
import net.brcdev.shopgui.ShopGuiPlusApi;
import net.brcdev.shopgui.exception.shop.ShopsNotLoadedException;
import net.brcdev.shopgui.shop.Shop;
import net.brcdev.shopgui.shop.item.ShopItem;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.scheduler.BukkitTask;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ItemPacketInterceptor {
    private final DynaShopPlugin plugin;
    private final Pattern shopIdPattern = Pattern.compile("(?:Magasin|Shop).*?[»\\-]\\s*([\\w\\s]+)");
    private final Pattern pagePattern = Pattern.compile("#(\\d+)");
    private final Pattern dynaShopPattern = Pattern.compile("%dynashop_current_([\\w]+)%");

    // Cache pour éviter de recalculer les mêmes valeurs trop souvent
    private final Map<String, Map<String, String>> priceCache = new ConcurrentHashMap<>();
    private final Map<String, Long> cacheTimes = new ConcurrentHashMap<>();
    private static final long CACHE_EXPIRY = 5000; // 5 secondes
    // private static final long CACHE_EXPIRY = 10000; // 10 secondes
    
    // Cache pour les lores traités - évite de retraiter les mêmes items
    private final Map<String, List<String>> processedLoreCache = new ConcurrentHashMap<>();
    private final Map<String, Long> loreCacheTimes = new ConcurrentHashMap<>();
    private static final long LORE_CACHE_EXPIRY = 5000; // 5 secondes

    // Thread pool pour les calculs asynchrones
    private final ExecutorService asyncExecutor;
    
    // Tâche périodique pour mettre à jour le cache en arrière-plan
    private BukkitTask cacheRefreshTask;
    
    // File des prix à charger de manière asynchrone
    private final ConcurrentLinkedQueue<String> pricesToLoad = new ConcurrentLinkedQueue<>();
    
    public ItemPacketInterceptor(DynaShopPlugin plugin) {
        this.plugin = plugin;
        this.asyncExecutor = Executors.newFixedThreadPool(2); // Limiter à 2 threads max
        
        registerPacketListener();
        startAsyncCacheRefresh();
        
        plugin.getLogger().info("ItemPacketInterceptor initialisé avec traitement asynchrone");
    }

    /**
     * Démarre une tâche périodique pour mettre à jour le cache de prix en arrière-plan
     */
    private void startAsyncCacheRefresh() {
        if (cacheRefreshTask != null) {
            cacheRefreshTask.cancel();
        }
        
        cacheRefreshTask = Bukkit.getScheduler().runTaskTimerAsynchronously(plugin, () -> {
            try {
                // Traiter jusqu'à 100 prix à la fois pour ne pas surcharger
                for (int i = 0; i < 100 && !pricesToLoad.isEmpty(); i++) {
                    String cacheKey = pricesToLoad.poll();
                    if (cacheKey == null) break;
                    
                    String[] parts = cacheKey.split(":");
                    if (parts.length != 2) continue;
                    
                    String shopId = parts[0];
                    String itemId = parts[1];
                    
                    // Ne pas recalculer si déjà dans le cache et récent
                    if (priceCache.containsKey(cacheKey)) {
                        long lastUpdate = cacheTimes.getOrDefault(cacheKey, 0L);
                        if (System.currentTimeMillis() - lastUpdate < CACHE_EXPIRY) {
                            continue;
                        }
                    }
                    
                    // Calculer les prix en arrière-plan et les mettre en cache
                    Map<String, String> prices = computePrices(shopId, itemId);
                    priceCache.put(cacheKey, prices);
                    cacheTimes.put(cacheKey, System.currentTimeMillis());
                }
                
                // Nettoyer les entrées expirées du cache pour éviter les fuites de mémoire
                long now = System.currentTimeMillis();
                
                // Nettoyer le cache de prix
                Iterator<Map.Entry<String, Long>> priceIterator = cacheTimes.entrySet().iterator();
                while (priceIterator.hasNext()) {
                    Map.Entry<String, Long> entry = priceIterator.next();
                    if (now - entry.getValue() > CACHE_EXPIRY) {
                        priceCache.remove(entry.getKey());
                        priceIterator.remove();
                    }
                }
                
                // Nettoyer le cache de lores
                Iterator<Map.Entry<String, Long>> loreIterator = loreCacheTimes.entrySet().iterator();
                while (loreIterator.hasNext()) {
                    Map.Entry<String, Long> entry = loreIterator.next();
                    if (now - entry.getValue() > LORE_CACHE_EXPIRY) {
                        processedLoreCache.remove(entry.getKey());
                        loreIterator.remove();
                    }
                }
            } catch (Exception e) {
                plugin.getLogger().warning("Erreur lors du rafraîchissement asynchrone du cache: " + e.getMessage());
            }
        }, 40L, 20L); // Exécuter toutes les secondes
    }
    
    // private void registerPacketListener() {
    //     ProtocolManager protocolManager = ProtocolLibrary.getProtocolManager();
        
    //     // Écouter les paquets d'affichage d'inventaire
    //     protocolManager.addPacketListener(new PacketAdapter(plugin, 
    //             ListenerPriority.NORMAL, 
    //             PacketType.Play.Server.WINDOW_ITEMS,
    //             PacketType.Play.Server.SET_SLOT) {
    //         @Override
    //         public void onPacketSending(PacketEvent event) {
    //             try {
    //                 Player player = event.getPlayer();
    //                 String title = player.getOpenInventory().getTitle();
                    
    //                 // Vérifier s'il s'agit d'un inventaire de shop
    //                 String shopIdWithPage = extractShopId(title);
    //                 if (shopIdWithPage == null) {
    //                     return;
    //                 }
    //                 int page = shopIdWithPage.contains("#") ? Integer.parseInt(shopIdWithPage.split("#")[1]) : 1;
    //                 String shopId = shopIdWithPage.split("#")[0];
                    
    //                 // Planifier un préchargement des prix pour ce shop de manière asynchrone
    //                 queueShopItemsForPreloading(shopId, page);
                    
    //                 if (event.getPacketType() == PacketType.Play.Server.WINDOW_ITEMS) {
    //                     handleWindowItemsPacket(event, shopId, page);
    //                 } else if (event.getPacketType() == PacketType.Play.Server.SET_SLOT) {
    //                     handleSetSlotPacket(event, shopId, page);
    //                 }
    //             } catch (Exception e) {
    //                 plugin.getLogger().warning("Erreur dans l'intercepteur de paquets: " + e.getMessage());
    //             }
    //         }
    //     });
    // }

    private void registerPacketListener() {
        ProtocolManager protocolManager = ProtocolLibrary.getProtocolManager();
        
        // Écouter les paquets d'affichage d'inventaire
        protocolManager.addPacketListener(new PacketAdapter(plugin, 
                ListenerPriority.NORMAL, 
                PacketType.Play.Server.WINDOW_ITEMS,
                PacketType.Play.Server.SET_SLOT) {
            @Override
            public void onPacketSending(PacketEvent event) {
                // Vérifications initiales sur le thread principal (obligatoire)
                final Player player = event.getPlayer();
                final String title = player.getOpenInventory().getTitle();
                
                // // Vérifier rapidement s'il s'agit d'un inventaire de shop
                // if (title == null || !title.contains("Magasin") && !title.contains("Shop")) {
                //     return;
                // }
                
                // Extraire le shopId de manière synchrone car nous avons besoin de l'API Bukkit
                String shopIdWithPage;
                try {
                    shopIdWithPage = extractShopId(title);
                    if (shopIdWithPage == null) {
                        return;
                    }
                } catch (Exception e) {
                    return; // Si une erreur se produit, laissez le paquet passer normalement
                }
                
                // final String finalShopIdWithPage = shopIdWithPage;
                final int page = shopIdWithPage.contains("#") ? Integer.parseInt(shopIdWithPage.split("#")[1]) : 1;
                final String shopId = shopIdWithPage.split("#")[0];
                
                // Planifier le préchargement de manière asynchrone
                asyncExecutor.submit(() -> {
                    try {
                        queueShopItemsForPreloading(shopId, page);
                    } catch (Exception e) {
                        // Ignorer - le préchargement n'est pas critique
                    }
                });
                
                // Créer une copie des données importantes avant de passer au thread asynchrone
                final PacketContainer packetCopy = event.getPacket().deepClone();
                final PacketType packetType = event.getPacketType();
                
                // Traiter le paquet de manière asynchrone
                event.setReadOnly(false); // Permettre de modifier le paquet plus tard
                
                // Utiliser le thread pool pour le traitement asynchrone
                asyncExecutor.submit(() -> {
                    try {
                        ItemStack[] processedItems = null;
                        
                        if (packetType == PacketType.Play.Server.WINDOW_ITEMS) {
                            processedItems = processWindowItemsAsync(packetCopy, player, shopId, page);
                        } else if (packetType == PacketType.Play.Server.SET_SLOT) {
                            processedItems = processSetSlotAsync(packetCopy, player, shopId, page);
                        }
                        
                        // Créer une copie finale de la variable pour utilisation dans la lambda
                        final ItemStack[] finalProcessedItems = processedItems;
                        
                        // Si nous avons des items traités, mettre à jour le paquet original sur le thread principal
                        if (finalProcessedItems != null) {
                            // // Revenir au thread principal pour mettre à jour le paquet
                            // Bukkit.getScheduler().runTask(plugin, () -> {
                            //     try {
                            //         if (packetType == PacketType.Play.Server.WINDOW_ITEMS) {
                            //             event.getPacket().getItemArrayModifier().write(0, finalProcessedItems);
                            //         } else if (packetType == PacketType.Play.Server.SET_SLOT) {
                            //             event.getPacket().getItemModifier().write(0, finalProcessedItems[0]);
                            //         }
                            //     } catch (Exception e) {
                            //         plugin.getLogger().warning("Erreur lors de la mise à jour du paquet: " + e.getMessage());
                            //     }
                            // });
                            // // Revenir au thread principal pour mettre à jour le paquet
                            // Bukkit.getScheduler().runTask(plugin, () -> {
                            //     try {
                            //         if (packetType == PacketType.Play.Server.WINDOW_ITEMS) {
                            //             // Vérifier que le modifier est valide et non vide
                            //             if (event.getPacket().getItemArrayModifier().size() > 0) {
                            //                 event.getPacket().getItemArrayModifier().write(0, finalProcessedItems);
                            //             } else {
                            //                 // Essayer avec la nouvelle API 1.17+
                            //                 if (event.getPacket().getItemListModifier().size() > 0) {
                            //                     List<ItemStack> itemList = new ArrayList<>(Arrays.asList(finalProcessedItems));
                            //                     event.getPacket().getItemListModifier().write(0, itemList);
                            //                 }
                            //             }
                            //         } else if (packetType == PacketType.Play.Server.SET_SLOT) {
                            //             // Vérifier que le modifier est valide et qu'il reste des items
                            //             if (finalProcessedItems.length > 0) {
                            //                 event.getPacket().getItemModifier().write(0, finalProcessedItems[0]);
                            //             }
                            //         }
                            //     } catch (Exception e) {
                            //         plugin.getLogger().warning("Erreur lors de la mise à jour du paquet: " + e.getMessage());
                            //     }
                            // });
                            // Annuler l'envoi du paquet original
                            event.setCancelled(true);
                            
                            // Créer un nouveau paquet à partir de la copie modifiée
                            Bukkit.getScheduler().runTask(plugin, () -> {
                                try {
                                    PacketContainer newPacket = packetCopy.shallowClone();
                                    
                                    if (packetType == PacketType.Play.Server.WINDOW_ITEMS) {
                                        try {
                                            newPacket.getItemArrayModifier().write(0, finalProcessedItems);
                                        } catch (Exception e1) {
                                            try {
                                                List<ItemStack> itemList = new ArrayList<>(Arrays.asList(finalProcessedItems));
                                                newPacket.getItemListModifier().write(0, itemList);
                                            } catch (Exception e2) {
                                                plugin.getLogger().warning("Impossible de mettre à jour le paquet: " + e2.getMessage());
                                                return;
                                            }
                                        }
                                    } else if (packetType == PacketType.Play.Server.SET_SLOT) {
                                        if (finalProcessedItems.length > 0) {
                                            newPacket.getItemModifier().write(0, finalProcessedItems[0]);
                                        }
                                    }
                                    
                                    // Envoyer le nouveau paquet
                                    try {
                                        ProtocolLibrary.getProtocolManager().sendServerPacket(player, newPacket);
                                    } catch (Exception e) {
                                        plugin.getLogger().warning("Erreur lors de l'envoi du nouveau paquet: " + e.getMessage());
                                    }
                                } catch (Exception e) {
                                    plugin.getLogger().warning("Erreur lors de la création du nouveau paquet: " + e.getMessage());
                                }
                            });
                        }
                    } catch (Exception e) {
                        plugin.getLogger().warning("Erreur dans le traitement asynchrone: " + e.getMessage());
                    }
                });
            }
        });
    }

    /**
     * Traite les items d'un paquet WINDOW_ITEMS de manière asynchrone
     */
    private ItemStack[] processWindowItemsAsync(PacketContainer packet, Player player, String shopId, int page) {
        try {
            // Essayer d'abord avec la méthode 1.17+
            try {
                List<ItemStack> items = packet.getItemListModifier().read(0);
                ItemStack[] resultArray = new ItemStack[items.size()];
                
                for (int i = 0; i < items.size(); i++) {
                    ItemStack item = items.get(i);
                    if (item != null && item.hasItemMeta()) {
                        resultArray[i] = processItemFast(player, item, shopId, page, i);
                    } else {
                        resultArray[i] = item;
                    }
                        // items.set(i, processItemFast(player, item, shopId, page, i));
                    // }
                }
                
                return resultArray;
            } catch (Exception e) {
                // Méthode alternative pour les versions antérieures
                ItemStack[] itemArray = packet.getItemArrayModifier().read(0);
                ItemStack[] resultArray = new ItemStack[itemArray.length];
                
                for (int i = 0; i < itemArray.length; i++) {
                    if (itemArray[i] != null && itemArray[i].hasItemMeta()) {
                        resultArray[i] = processItemFast(player, itemArray[i], shopId, page, i);
                    } else {
                        resultArray[i] = itemArray[i];
                    }
                }
                
                return resultArray;
            }
        } catch (Exception e) {
            plugin.getLogger().warning("Erreur lors du traitement asynchrone du paquet WINDOW_ITEMS: " + e.getMessage());
            return null;
        }
    }

    /**
     * Traite un paquet SET_SLOT de manière asynchrone
     */
    private ItemStack[] processSetSlotAsync(PacketContainer packet, Player player, String shopId, int page) {
        try {
            ItemStack item = packet.getItemModifier().read(0);
            int slot = packet.getIntegers().read(1);
            
            if (item != null && item.hasItemMeta()) {
                ItemStack processedItem = processItemFast(player, item, shopId, page, slot);
                return new ItemStack[] { processedItem };
            }
            
            return new ItemStack[] { item };
        } catch (Exception e) {
            plugin.getLogger().warning("Erreur lors du traitement asynchrone du paquet SET_SLOT: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Ajoute tous les items d'un shop à la file d'attente pour préchargement
     */
    private void queueShopItemsForPreloading(String shopId, int page) {
        try {
            Shop shop = ShopGuiPlusApi.getPlugin().getShopManager().getShopById(shopId);
            if (shop == null) return;
            
            // Ajouter tous les items à la file d'attente pour préchargement
            for (ShopItem shopItem : shop.getShopItems()) {
                String cacheKey = shopId + ":" + shopItem.getId();
                if (!priceCache.containsKey(cacheKey) || 
                    System.currentTimeMillis() - cacheTimes.getOrDefault(cacheKey, 0L) > CACHE_EXPIRY) {
                    pricesToLoad.offer(cacheKey);
                }
            }
        } catch (Exception e) {
            // Ignorer les erreurs, c'est juste du préchargement
        }
    }
    
    private void handleWindowItemsPacket(PacketEvent event, String shopId, int page) {
        PacketContainer packet = event.getPacket();
        Player player = event.getPlayer();
        
        // Les méthodes d'accès dépendent de la version de Minecraft, je vais utiliser les plus courantes
        try {
            // Pour les versions 1.17+
            List<ItemStack> items = packet.getItemListModifier().read(0);
            for (int i = 0; i < items.size(); i++) {
                ItemStack item = items.get(i);
                if (item != null && item.hasItemMeta()) {
                    // ItemStack processedItem = processItem(player, item, shopId, page, i);
                    ItemStack processedItem = processItemFast(player, item, shopId, page, i);
                    items.set(i, processedItem);
                }
            }
            packet.getItemListModifier().write(0, items);
        } catch (Exception e) {
            try {
                // Méthode alternative pour les versions antérieures
                ItemStack[] itemArray = packet.getItemArrayModifier().read(0);
                for (int i = 0; i < itemArray.length; i++) {
                    if (itemArray[i] != null && itemArray[i].hasItemMeta()) {
                        // itemArray[i] = processItem(player, itemArray[i], shopId, page, i);
                        itemArray[i] = processItemFast(player, itemArray[i], shopId, page, i);
                    }
                }
                packet.getItemArrayModifier().write(0, itemArray);
            } catch (Exception e2) {
                plugin.getLogger().warning("Erreur lors du traitement du paquet WINDOW_ITEMS: " + e2.getMessage());
            }
        }
    }
    
    private void handleSetSlotPacket(PacketEvent event, String shopId, int page) {
        PacketContainer packet = event.getPacket();
        Player player = event.getPlayer();
        
        try {
            ItemStack item = packet.getItemModifier().read(0);
            // int slot = packet.getIntegers().read(0);
            int slot = packet.getIntegers().read(1);
            if (item != null && item.hasItemMeta()) {
                // ItemStack processedItem = processItem(player, item, shopId, page, slot);
                ItemStack processedItem = processItemFast(player, item, shopId, page, slot);
                packet.getItemModifier().write(0, processedItem);
            }
        } catch (Exception e) {
            plugin.getLogger().warning("Erreur lors du traitement du paquet SET_SLOT: " + e.getMessage());
        }
    }
    
    /**
     * Version optimisée de processItem qui utilise un cache pour éviter le retraitement
     */
    private ItemStack processItemFast(Player player, ItemStack item, String shopId, int page, int slot) {
        if (item == null || !item.hasItemMeta()) {
            return item;
        }
        
        ItemMeta meta = item.getItemMeta();
        if (meta == null || !meta.hasLore()) {
            return item;
        }
        
        List<String> lore = meta.getLore();
        if (lore == null || lore.isEmpty()) {
            return item;
        }
        
        // Vérifier rapidement s'il y a des placeholders
        boolean hasDynaShopPlaceholder = false;
        for (String line : lore) {
            if (line.contains("%dynashop_")) {
                hasDynaShopPlaceholder = true;
                break;
            }
        }
        
        if (!hasDynaShopPlaceholder) {
            return item;
        // } else {
        //     plugin.getLogger().info("Item avec placeholder trouvé pour le joueur " + player.getName());
        }
        
        try {
            // Essayer d'obtenir l'ID de l'item 
            String itemId = null;
            try {
                ShopItem shopItem = ShopGuiPlusApi.getPlugin().getShopManager().getShopById(shopId).getShopItem(page, slot);
                if (shopItem != null) {
                    itemId = shopItem.getId();
                    // plugin.getLogger().info("ID de l'item trouvé: " + itemId);
                }
            } catch (Exception e) {
                // Si ça échoue, essayer d'extraire l'ID à partir du lore
                // itemId = extractItemIdFromLore(lore);
                // plugin.getLogger().warning("Erreur lors de la recherche de l'ID d'item: " + e.getMessage());
            }
            
            if (itemId == null) {
                // plugin.getLogger().warning("Impossible de déterminer l'ID de l'item pour shopId: " + shopId + ", page: " + page + ", slot: " + slot);
                // Si on ne peut pas déterminer l'ID, retourner l'item non modifié
                return item;
            }
            
            // Générer une clé de cache composite pour cet item
            String loreKey = shopId + ":" + itemId + ":" + player.getUniqueId();
            
            // Vérifier si nous avons déjà traité cet item récemment
            if (processedLoreCache.containsKey(loreKey)) {
                long lastUpdate = loreCacheTimes.getOrDefault(loreKey, 0L);
                if (System.currentTimeMillis() - lastUpdate < LORE_CACHE_EXPIRY) {
                    // Utiliser le lore en cache
                    List<String> cachedLore = processedLoreCache.get(loreKey);
                    meta.setLore(cachedLore);
                    item.setItemMeta(meta);
                    return item;
                }
            }
            
            // Si pas dans le cache, créer un nouveau lore
            // plugin.getLogger().info("Lore original: " + lore);
            List<String> newLore = processLore(player, lore, shopId, itemId);
            // plugin.getLogger().info("Lore traité: " + newLore);
            
            // Mettre à jour le cache
            processedLoreCache.put(loreKey, newLore);
            loreCacheTimes.put(loreKey, System.currentTimeMillis());
            
            // Appliquer le nouveau lore
            meta.setLore(newLore);
            item.setItemMeta(meta);
            
            // Précharger les prix pour les prochaines fois
            String priceKey = shopId + ":" + itemId;
            if (!priceCache.containsKey(priceKey) || 
                System.currentTimeMillis() - cacheTimes.getOrDefault(priceKey, 0L) > CACHE_EXPIRY) {
                pricesToLoad.offer(priceKey);
            }
            
            return item;
        } catch (Exception e) {
            plugin.getLogger().warning("Erreur lors du traitement rapide d'un item: " + e.getMessage());
            return item;
        }
    }
    
    /**
     * Crée un nouveau lore avec les placeholders remplacés
     */
    private List<String> processLore(Player player, List<String> lore, String shopId, String itemId) {
        // Obtenir les prix depuis le cache ou les calculer
        Map<String, String> prices = getPrices(shopId, itemId);
        // plugin.getLogger().info("Prix pour l'item " + itemId + ": " + prices);
        
        List<String> newLore = new ArrayList<>();
        for (String line : lore) {
            if (line.contains("%dynashop_current_")) {
                // plugin.getLogger().info("Ligne avec placeholder DynaShop trouvée: " + line);
                // Décider si la ligne doit être omise
                boolean skipLine = shouldSkipLine(line, prices);

                if (!skipLine) {
                    // Remplacer les placeholders DynaShop
                    String processedLine = replacePlaceholders(line, prices);
                    
                    // 3. Traiter les autres placeholders via PlaceholderAPI si nécessaire
                    if (processedLine.contains("%")) {
                        processedLine = PlaceholderAPI.setPlaceholders(player, processedLine);
                    }
                    
                    // 4. Ajouter la ligne traitée
                    newLore.add(processedLine);
                }
            } else {
                // Pour les lignes sans placeholders DynaShop
                String processedLine = line;
                if (line.contains("%")) {
                    processedLine = PlaceholderAPI.setPlaceholders(player, line);
                }
                newLore.add(processedLine);
            }
        }
        
        return newLore;
    }
    
    private ItemStack processItem(Player player, ItemStack item, String shopId, int page, int slot) {
        if (item == null || !item.hasItemMeta()) {
            return item;
        }
        
        ItemMeta meta = item.getItemMeta();
        if (meta == null || !meta.hasLore()) {
            return item;
        }
        
        List<String> lore = meta.getLore();
        if (lore == null || lore.isEmpty()) {
            return item;
        }
        
        // Vérifier si le lore contient des placeholders DynaShop
        boolean hasDynaShopPlaceholder = false;
        for (String line : lore) {
            if (line.contains("%dynashop_")) {
                hasDynaShopPlaceholder = true;
                break;
            }
        }
        
        if (!hasDynaShopPlaceholder) {
            return item;
        }
        
        // Extraire l'ID de l'item à partir des métadonnées ou du lore
        String itemId = extractItemId(item, shopId, page, slot);
        if (itemId == null) {
            return item;
        }
        
        // Obtenir les valeurs de prix
        Map<String, String> prices = getPrices(shopId, itemId);
        // plugin.getLogger().info("Prix pour l'item " + itemId + ": " + prices);
        
        // Créer un nouveau lore avec les placeholders remplacés
        List<String> newLore = new ArrayList<>();
        for (String line : lore) {
            // Vérifier si la ligne contient des placeholders à traiter
            if (line.contains("%dynashop_current_")) {
                // Décider si la ligne doit être omise
                boolean skipLine = shouldSkipLine(line, prices);
                
                if (!skipLine) {
                    // Remplacer les placeholders DynaShop
                    String processedLine = replacePlaceholders(line, prices);
                    
                    // Traiter les autres placeholders via PlaceholderAPI
                    if (processedLine.contains("%")) {
                        processedLine = PlaceholderAPI.setPlaceholders(player, processedLine);
                    }
                    
                    newLore.add(processedLine);
                }
            } else {
                // Pour les lignes sans placeholders DynaShop
                String processedLine = line;
                if (line.contains("%")) {
                    processedLine = PlaceholderAPI.setPlaceholders(player, line);
                }
                newLore.add(processedLine);
            }
        }
        
        // Mettre à jour le lore de l'item
        meta.setLore(newLore);
        item.setItemMeta(meta);
        
        return item;
    }
    
    private boolean shouldSkipLine(String line, Map<String, String> prices) {
        // Vérifier les conditions pour masquer certaines lignes
        if ((line.contains("%dynashop_current_buyPrice%") || line.contains("%dynashop_current_buy%")) && 
            (prices.get("buy").equals("N/A") || prices.get("buy").equals("0.0"))) {
            return true;
        }
        
        if ((line.contains("%dynashop_current_sellPrice%") || line.contains("%dynashop_current_sell%")) && 
            (prices.get("sell").equals("N/A") || prices.get("sell").equals("0.0"))) {
            return true;
        }
        
        return false;
    }
    
    private String replacePlaceholders(String line, Map<String, String> prices) {
        return line.replace("%dynashop_current_buyPrice%", prices.get("buy"))
                   .replace("%dynashop_current_sellPrice%", prices.get("sell"))
                   .replace("%dynashop_current_buyMinPrice%", prices.get("buy_min"))
                   .replace("%dynashop_current_buyMaxPrice%", prices.get("buy_max"))
                   .replace("%dynashop_current_sellMinPrice%", prices.get("sell_min"))
                   .replace("%dynashop_current_sellMaxPrice%", prices.get("sell_max"))
                   .replace("%dynashop_current_buy%", prices.get("base_buy"))
                   .replace("%dynashop_current_sell%", prices.get("base_sell"));
    }
    
    // private Map<String, String> getPrices(String shopId, String itemId) {
    //     String cacheKey = shopId + ":" + itemId;
        
    //     // Vérifier si nous avons des valeurs mises en cache récemment
    //     if (priceCache.containsKey(cacheKey)) {
    //         long lastUpdate = cacheTimes.getOrDefault(cacheKey, 0L);
    //         if (System.currentTimeMillis() - lastUpdate < CACHE_EXPIRY) {
    //             return priceCache.get(cacheKey);
    //         }
    //     }
        
    //     // Obtenir les valeurs de l'API DynaShop
    //     Map<String, String> prices = new HashMap<>();
        
    //     // Obtenir la devise
    //     String currencyPrefix = "";
    //     String currencySuffix = "";
    //     try {
    //         currencyPrefix = ShopGuiPlusApi.getPlugin().getEconomyManager()
    //             .getEconomyProvider(ShopGuiPlusApi.getShop(shopId).getEconomyType()).getCurrencyPrefix();
    //         currencySuffix = ShopGuiPlusApi.getPlugin().getEconomyManager()
    //             .getEconomyProvider(ShopGuiPlusApi.getShop(shopId).getEconomyType()).getCurrencySuffix();
    //     } catch (Exception e) {
    //         // Ignorer les erreurs
    //     }
        
    //     // Obtenir les prix
    //     prices.put("buy", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "buy"));
    //     prices.put("sell", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "sell"));
    //     prices.put("buy_min", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "buy_min"));
    //     prices.put("buy_max", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "buy_max"));
    //     prices.put("sell_min", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "sell_min"));
    //     prices.put("sell_max", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "sell_max"));
        
    //     // Préparer les formats composites
    //     String buyPrice = prices.get("buy");
    //     String buyMinPrice = prices.get("buy_min");
    //     String buyMaxPrice = prices.get("buy_max");
        
    //     if (!buyMinPrice.equals("N/A") && !buyMaxPrice.equals("N/A")) {
    //         prices.put("base_buy", String.format(currencyPrefix + "%s" + currencySuffix + " §7(%s - %s)", 
    //             buyPrice, buyMinPrice, buyMaxPrice));
    //     } else {
    //         prices.put("base_buy", currencyPrefix + buyPrice + currencySuffix);
    //     }
        
    //     String sellPrice = prices.get("sell");
    //     String sellMinPrice = prices.get("sell_min");
    //     String sellMaxPrice = prices.get("sell_max");
        
    //     if (!sellMinPrice.equals("N/A") && !sellMaxPrice.equals("N/A")) {
    //         prices.put("base_sell", String.format(currencyPrefix + "%s" + currencySuffix + " §7(%s - %s)", 
    //             sellPrice, sellMinPrice, sellMaxPrice));
    //     } else {
    //         prices.put("base_sell", currencyPrefix + sellPrice + currencySuffix);
    //     }
        
    //     // Mettre à jour le cache
    //     priceCache.put(cacheKey, prices);
    //     cacheTimes.put(cacheKey, System.currentTimeMillis());
        
    //     return prices;
    // }
    
    /**
     * Version optimisée pour obtenir les prix (utilise le cache)
     */
    private Map<String, String> getPrices(String shopId, String itemId) {
        String cacheKey = shopId + ":" + itemId;
        
        // Vérifier le cache
        if (priceCache.containsKey(cacheKey)) {
            long lastUpdate = cacheTimes.getOrDefault(cacheKey, 0L);
            if (System.currentTimeMillis() - lastUpdate < CACHE_EXPIRY) {
                return priceCache.get(cacheKey);
            }
        }
        
        // Si pas dans le cache, calculer les prix
        Map<String, String> prices = computePrices(shopId, itemId);
        
        // Mettre à jour le cache
        priceCache.put(cacheKey, prices);
        cacheTimes.put(cacheKey, System.currentTimeMillis());
        
        return prices;
    }
    
    /**
     * Calcule les prix pour un item (opération potentiellement coûteuse)
     */
    private Map<String, String> computePrices(String shopId, String itemId) {
        Map<String, String> prices = new HashMap<>();
        
        try {
            // Obtenir la devise
            String currencyPrefix = "";
            String currencySuffix = "";
            try {
                currencyPrefix = ShopGuiPlusApi.getPlugin().getEconomyManager()
                    .getEconomyProvider(ShopGuiPlusApi.getShop(shopId).getEconomyType()).getCurrencyPrefix();
                currencySuffix = ShopGuiPlusApi.getPlugin().getEconomyManager()
                    .getEconomyProvider(ShopGuiPlusApi.getShop(shopId).getEconomyType()).getCurrencySuffix();
            } catch (Exception e) {
                // Ignorer les erreurs
            }
            
            // Obtenir les prix
            prices.put("buy", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "buy"));
            prices.put("sell", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "sell"));
            prices.put("buy_min", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "buy_min"));
            prices.put("buy_max", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "buy_max"));
            prices.put("sell_min", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "sell_min"));
            prices.put("sell_max", plugin.getPlaceholderExpansion().getPriceByType(shopId, itemId, "sell_max"));
            
            // Préparer les formats composites
            String buyPrice = prices.get("buy");
            String buyMinPrice = prices.get("buy_min");
            String buyMaxPrice = prices.get("buy_max");
            
            if (!buyMinPrice.equals("N/A") && !buyMaxPrice.equals("N/A")) {
                prices.put("base_buy", String.format(currencyPrefix + "%s" + currencySuffix + " §7(%s - %s)", 
                    buyPrice, buyMinPrice, buyMaxPrice));
            } else {
                prices.put("base_buy", currencyPrefix + buyPrice + currencySuffix);
            }
            
            String sellPrice = prices.get("sell");
            String sellMinPrice = prices.get("sell_min");
            String sellMaxPrice = prices.get("sell_max");
            
            if (!sellMinPrice.equals("N/A") && !sellMaxPrice.equals("N/A")) {
                prices.put("base_sell", String.format(currencyPrefix + "%s" + currencySuffix + " §7(%s - %s)", 
                    sellPrice, sellMinPrice, sellMaxPrice));
            } else {
                prices.put("base_sell", currencyPrefix + sellPrice + currencySuffix);
            }
        } catch (Exception e) {
            plugin.getLogger().warning("Erreur lors du calcul des prix: " + e.getMessage());
            // Valeurs par défaut en cas d'erreur
            prices.put("buy", "N/A");
            prices.put("sell", "N/A");
            prices.put("buy_min", "N/A");
            prices.put("buy_max", "N/A");
            prices.put("sell_min", "N/A");
            prices.put("sell_max", "N/A");
            prices.put("base_buy", "N/A");
            prices.put("base_sell", "N/A");
        }
        
        return prices;
    }
    
    // /**
    //  * Extrait l'ID de l'item à partir du lore s'il y est mentionné
    //  */
    // private String extractItemIdFromLore(List<String> lore) {
    //     for (String line : lore) {
    //         if (line.contains("ID:")) {
    //             String[] parts = line.split("ID:");
    //             if (parts.length > 1) {
    //                 return parts[1].trim();
    //             }
    //         }
    //     }
    //     return null;
    // }

    
    private String extractItemId(ItemStack item, String shopId, int page, int slot) {
        // // Méthode 1: Extraire l'ID à partir des métadonnées NBT (si ShopGUI+ les stocke)
        // try {
        //     // NbtCompound compound = NbtFactory.asCompound(NbtFactory.fromItemOptional(item));
        //     NbtCompound compound = NbtFactory.fromNMSCompound(NbtFactory.fromItemOptional((ItemStack) item));
        //     if (compound.containsKey("SGPItemId")) {
        //         return compound.getString("SGPItemId");
        //     }
        // } catch (Exception e) {
        //     // Ignorer et continuer avec d'autres méthodes
        // }
        
        // // Méthode 2: Essayer d'extraire l'ID à partir du lore (peut être indiqué dans une ligne spécifique)
        // ItemMeta meta = item.getItemMeta();
        // if (meta != null && meta.hasLore()) {
        //     List<String> lore = meta.getLore();
        //     for (String line : lore) {
        //         if (line.contains("ID:")) {
        //             String[] parts = line.split("ID:");
        //             if (parts.length > 1) {
        //                 return parts[1].trim();
        //             }
        //         }
        //     }
        // }
        
        // Méthode 3: Essayer d'obtenir par l'API ShopGUI+
        // try {
            // for (int itemSlot = 0; itemSlot < ShopGuiPlusApi.getShop(shopId).getShopItems().size(); itemSlot++) {
            //     if (ShopGuiPlusApi.getShop(shopId).getShopItem(itemSlot).getItem().isSimilar(item)) {
            //         return ShopGuiPlusApi.getShop(shopId).getShopItem(itemSlot).getId();
            //     }
            // }
            // for (ShopItem shopItem : ShopGuiPlusApi.getShop(shopId).getShopItems()) {
            //     if (shopItem.getItem().isSimilar(item)) {
            //         return shopItem.getId();
            //     }
            // }
            return ShopGuiPlusApi.getPlugin().getShopManager().getShopById(shopId).getShopItem(page, slot).getId();
        // } catch (Exception e) {
        //     // Ignorer et continuer
        // }
        
        // // Si toutes les méthodes échouent, utiliser le nom de l'item comme fallback
        // if (meta != null && meta.hasDisplayName()) {
        //     String displayName = ChatColor.stripColor(meta.getDisplayName());
        //     return displayName.toLowerCase().replace(" ", "_");
        // }
        
        // Dernier recours: générer un ID basé sur le type de matériau
        // return item.toString();
    }
    
    private String extractShopId(String title) throws ShopsNotLoadedException {
        if (title == null) return null;
        
        // Nettoyer le titre
        String cleanTitle = ChatColor.stripColor(title);
        
        // Extraire le nom du shop
        Matcher shopMatcher = shopIdPattern.matcher(cleanTitle);
        if (!shopMatcher.find()) return null;
        
        String shopName = shopMatcher.group(1).trim();
        
        // Rechercher dans la liste des shops pour trouver l'ID
        try {
            // for (String shopId : ShopGuiPlusApi.getPlugin().getShopManager().getShops().toArray(new String[0])) {
            //     String currentShopName = ShopGuiPlusApi.getShop(shopId).getName();
            for (Shop shop : ShopGuiPlusApi.getPlugin().getShopManager().getShops()) {
                String shopId = shop.getId();
                if (shopId.equalsIgnoreCase(shopName) || cleanTitle.contains(shopId)) {
                    // Extraire le numéro de page si présent
                    Matcher pageMatcher = pagePattern.matcher(cleanTitle);
                    if (pageMatcher.find()) {
                        return shopId + "#" + pageMatcher.group(1);
                    }
                    return shopId + "#1"; // Page 1 par défaut
                }
            }
        } catch (Exception e) {
            plugin.getLogger().warning("Erreur lors de l'extraction du shop ID: " + e.getMessage());
        }
        
        // Essayer de correspondre directement avec l'ID (certains shops peuvent avoir l'ID dans le titre)
        // for (String shopId : ShopGuiPlusApi.getPlugin().getShopManager().getShops().toArray(new String[0])) {
        for (Shop shop : ShopGuiPlusApi.getPlugin().getShopManager().getShops()) {
            String shopId = shop.getId();
            if (cleanTitle.toLowerCase().contains(shopId.toLowerCase())) {
                Matcher pageMatcher = pagePattern.matcher(cleanTitle);
                if (pageMatcher.find()) {
                    return shopId + "#" + pageMatcher.group(1);
                }
                return shopId + "#1";
            }
        }
        
        return null;
    }
    
    public void clearCache() {
        priceCache.clear();
        cacheTimes.clear();
    }
    
    /**
     * Nettoie les caches et arrête les tâches planifiées
     */
    public void shutdown() {
        // Annuler la tâche de rafraîchissement du cache
        if (cacheRefreshTask != null) {
            cacheRefreshTask.cancel();
            cacheRefreshTask = null;
        }
        
        // Arrêter l'exécuteur asynchrone
        if (asyncExecutor != null) {
            asyncExecutor.shutdown();
            try {
                // Attendre jusqu'à 1 seconde pour la terminaison
                asyncExecutor.awaitTermination(1, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                // Ignorer
            }
        }
        
        // Vider les caches
        priceCache.clear();
        cacheTimes.clear();
        processedLoreCache.clear();
        loreCacheTimes.clear();
        pricesToLoad.clear();
    }
}